<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>Vue八股文 | 你别睡这么晚！</title><meta name="keywords" content="Vue,八股文"><meta name="author" content="你别睡这么晚"><meta name="copyright" content="你别睡这么晚"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="Vue八股文"><meta name="application-name" content="Vue八股文"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="Vue八股文"><meta property="og:url" content="https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/index.html"><meta property="og:site_name" content="你别睡这么晚！"><meta property="og:description" content="Vue 的设计模式介绍一下 MVVM 模式，和 MVC 模式有什么区别？MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图（View）指的是所看到的页面。视图模型（ViewModel）是 MVVM 模式的核心，它是连接"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://avatars.githubusercontent.com/u/47170023?v=4"><meta property="article:author" content="你别睡这么晚"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://avatars.githubusercontent.com/u/47170023?v=4"><meta name="description" content="Vue 的设计模式介绍一下 MVVM 模式，和 MVC 模式有什么区别？MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图（View）指的是所看到的页面。视图模型（ViewModel）是 MVVM 模式的核心，它是连接"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/"><link rel="preconnect" href="//npm.elemecdn.com"/><link rel="preconnect" href="//npm.onmicrosoft.cn"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":15},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":16,"endTime":18},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":19,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: {"appId":"K880G321DE","apiKey":"5c9b9d0f591eb08ace149bf3d24ed065","indexName":"hexo","hits":{"per_page":6},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 你别睡这么晚","link":"链接: ","source":"来源: 你别睡这么晚！","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '你别睡这么晚！',
  title: 'Vue八股文',
  postAI: '',
  pageFillDescription: 'Vue 的设计模式, 介绍一下 MVVM 模式和 MVC 模式有什么区别？, 生命周期, Vue2 的生命周期有哪些, keep-alive 中的生命周期有哪些, 父子组件生命周期执行顺序, 1.挂载阶段, 2.更新阶段, 3.销毁阶段, 总结：, 平时发送异步请求在哪个生命周期并解释原因, 【延伸问答】created 和 mouted 区别, 1. Vue面试题, 1.1 v-model 作用？, 1.2 v-model 实现原理？, 1.3 Vue2.0 双向绑定的缺陷？, 1.4 Vue3.0 实现数据双向绑定的方法, 1.5 Vuex是什么每个属性是干嘛的如何使用, 1.6 Vuex实现原理, 1.7 mutation和action有什么区别？, 1.8 修改ElementUI 样式的几种方式?, 1.9 elementui 有什么用?, 1.10 导航守卫, 1.11 路由守卫进行判断登录, 1.12 vue-router 实现懒加载, 1.13 js是如何监听HistoryRouter的变化的, 1.14 HashRouter 和 HistoryRouter的区别和原理, 1.15 Vue router 原理 哪个模式不会请求服务器, 1.16 组件通信的方式, 1.17 vue组件间传值 attrs和listeners 了解过吗？, 1.18 组建传值事件总线是怎么用的, 1.19 vue生命周期中异步加载在mouted还是create里实现, 1.20 vue钩子函数(重点问了keep-alive), 1.21 vue keep-alive, 1.22 既然函数是引用类型为什么 vue 的 data 还是可以用函数, 1.23 vue 中 $nextTick 作用与原理, 1.24 vue的特性, 1.25 v-if v-show区别, 1.26 Vue 列表为什么加 key, , 1.27 jquery 和 vue相比, 1.28 为什么选择用vue做页面展示, 1.29 vuex2Fangular区别, 1.30 双向数据绑定原理, 1.31 既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化为什么还需要虚拟 DOM diff 呢?, 1.32 简单聊聊 new Vue 以后发生的事情, 1.33 v-for中的key的理解？, 1.34 vue首屏白屏如何解决？, 1.35 vue单页面和传统的多页面区别？, 1.36 refs、$parent的使用？, 1.36 路由跳转和location.href的区别？, 1.37 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？, 1.38 delete与vue.delete区别?, 1.39 computed和watch的区别, 1.40 Vue 为什么要用 vm.$set() 解决对象新增属性不能响应的问题 ？你能说说如下代码的实现原理么？的设计模式介绍一下模式和模式有什么区别即的简写即模型视图视图模型模型指的是后端传递的数据视图指的是所看到的页面视图模型是模式的核心它是连接和的桥梁视图模型有两个方向的作用将模型转化成视图即将后端传递的数据转化成所看到的页面实现的方式是数据绑定将视图转化成模型即将所看到的页面转化成后端的数据实现的方式是事件监听当这两个方向的数据转换都实现时我们称之为数据的双向绑定模型图解是的简写即模型视图控制器和指的意思和中的和意思一样即指的是页面业务逻辑使用的目的就是将和的代码分离是单向通信也就是跟必须通过来承上启下模型图解与最大的区别就是实现了和的自动同步也就是当的属性改变时我们不用再自己手动操作元素来改变的显示而是改变属性后该属性对应层显示会自动改变双向绑定生命周期的生命周期有哪些生命周期可以理解为三部分第一部分为初始化实例的过程第二部分为数据渲染更新的过程第三部分为销毁实例的过程每一个部分都有对应的钩子函数来完成对应的部分过程初始化阶段的钩子函数实例创建前模板和数据均未获取到实例创建后最早可以获得数据但模板还未获取到数据挂载前模板已经获取到但是数据未挂载到模板上数据挂载后数据已挂载到模板中更新阶段的钩子函数模板更新前改变后更新数据模板前调用模板更新后将渲染到数据模板中销毁阶段的钩子函数实例销毁前实例销毁后中的生命周期有哪些是提供的一个内置组件用来对组件进行缓存在组件切换过程中将状态保留在内存中防止重复渲染如果为一个组件包裹了那么它会多出两个生命周期同时和就不会再被触发了因为组件不会被真正销毁当组件被换掉时会被缓存到内存中触发生命周期当组件被切回来时再去缓存里找这个组件触发钩子函数父子组件生命周期执行顺序挂载阶段该过程主要涉及个钩子函数执行顺序为父父父子子子子父一定得等子组件挂载完毕后父组件才能挂在完毕所以父组件的在最后更新阶段该过程主要涉及个钩子函数注意当父子组件有数据传递时才有这个更新阶段执行顺序的比较执行顺序为父子子父销毁阶段该过程主要涉及个钩子函数执行顺序为父子子父总结当父组件执行完挂载开始后会依次执行子组件中的钩子直到全部子组件挂载到实例上父组件才会进入钩子子级触发事件会先触发父级钩子再去触发子级钩子下面又是先执行子级钩子后执行父级钩子平时发送异步请求在哪个生命周期并解释原因我们可以在钩子函数中进行调用因为在这三个钩子函数中已经创建可以将服务端端返回的数据进行赋值推荐在钩子函数中调用异步请求因为在钩子函数中调用异步请求有以下优点能更快获取到服务端数据减少页面加载时间用户体验更好不支持钩子函数放在中有助于一致性延伸问答和区别生命周期钩子函数会在组件实例被创建之后立即调用但是此时组件的模板还没有被渲染成因此在这个时候不能访问组件中的元素生命周期钩子函数则会在组件的模板被渲染成之后调用这个时候可以访问组件中的元素通常在这个钩子函数中进行异步请求数据初始化插件订阅事件等操作总之钩子函数适用于组件初始化时需要进行一些操作而钩子函数适用于需要操作组件的元素时面试题作用参考答案本质上不过是语法糖可以用指令在表单及元素上创建双向数据绑定它会根据控件类型自动选取正确的方法来更新元素它负责监听用户的输入事件以更新数据并对一些极端场景进行一些特殊处理会忽略所有表单元素的特性的初始值而总是将实例的数据作为数据来源因此我们应该通过在组件的选项中声明初始值扩展在内部为不同的输入元素使用不同的属性并抛出不同的事件和元素使用属性和事件和使用属性和事件字段将作为并将作为事件实现原理参考答案只不过是一个语法糖而已真正的实现靠的还是绑定响应式数据触发事件并传递数据等同于自开始每次输入都会触发事件所以输入时的内容会绑定到中于是的值就被改变指代当前触发的事件对象指代当前触发的事件对象的就是当前的值在方法中在中双向绑定的缺陷参考答案的数据响应是采用数据劫持结合发布者订阅者模式的方式通过来劫持各个属性的但是它并不算是实现数据的响应式的完美方案某些情况下需要对其进行修补或者这也是它的缺陷主要表现在两个方面实例创建后无法检测到对象属性的新增或删除只能追踪到数据是否被修改不能监听数组的变化解析实例创建后无法检测到对象属性的新增或删除只能追踪到数据是否被修改只能劫持对象的属性当创建一个实例时将遍历所有对象并为每个数据属性添加了和和允许观察数据的更改并触发更新但是如果你在实例化后添加或删除一个属性这个属性不会被处理改变和解决方案响应式对象的子对象新增属性可以给子响应式对象重新赋值不能监听数组的变化在实现数组的响应式时它使用了一些把无法监听数组的情况通过重写数组的部分方法来实现响应式这也只限制在数组的七个方法其他数组方法及数组的使用则无法检测到例如如下两种使用方式实现数组响应式的方法通过重写数组的对应的方法具体来说就是重新指定要操作数组的并重新该中对应上面的个数组方法通过下面代码简单了解下实现原理复制并将其指向重写中的数组方法视图更新数组实现响应式改变传入数组的对象的响应式实现实现数据双向绑定的方法参考答案实现数据双向绑定是通过是中新增的一个特性翻译过来意思是代理用在这里表示由它来代理某些操作让我们能够以简洁易懂的方式控制外部对对象的访问其功能非常类似于设计模式中的代理模式可以理解成在目标对象之前架设一层拦截外界对该对象的访问都必须先通过这层拦截因此提供了一种机制可以对外界的访问进行过滤和改写使用的核心优点是可以交由它来处理一些非核心逻辑如读取或设置对象的某些属性前记录日志设置对象的某些属性值前需要验证某些属性的访问控制等从而可以让对象只需关注于核心逻辑达到关注点分离降低对象复杂度等目的扩展使用实现双向数据绑定相比的优势可以劫持整个对象并返回一个新对象有种劫持操作是什么每个属性是干嘛的如何使用参考答案是什么是专门为应用程序设计的状态管理工具它采用集中式存储管理应用的所有组件的状态并以相应的规则保证状态以一种可预测的方式发生变化具体工作是一种状态管理机制将全局组件的共享状态抽取出来为一个以一个单例模式存在应用任何一个组件中都可以使用更改的唯一途径是通过需要触发实际触发是其中处理同步任务处理异步任务每个属性是干嘛的的属性包含以下个是存储的单一状态是存储的基本数据是的计算属性对的加工是派生出来的数据就像计算属性一样返回的值会根据它的依赖被缓存起来且只有当它的依赖值发生改变才会被重新计算提交更改数据使用方法更改存储的状态同步函数像一个装饰器提交而不是直接变更状态可以包含任何异步操作是分割的模块每个模块拥有自己的的状态的状态辅助函数提供了等辅助函数给开发在中处理的使用方法的插件机制安装实例化调用方法注入挂载实例实现原理参考答案通过以下三个方面来阐述的实现原理是怎么注册的是怎么实现的辅助函数是怎么实现的是怎么注册的我们看到在的生命周期中的初始化钩子前插入一段初始化代码给的实例注入一个的属性这也就是为什么我们在的组件中可以通过访问到的各种数据和状态获取当前的版本通过的方式注入兼容使用自定义的方法并替换对象原型的方法实现注入注入子组件从其父组件引用属性是怎么实现的获取的对应的没有就创建一个空数组处理过的调用用户定义的并传入和参数是对的的初始化它接受个参数为当前实例为的为执行的回调函数为当前模块的路径的作用就是同步修改当前模块的函数首先通过拿到对应的对象数组然后把一个的包装函数到这个数组中这个函数接收一个参数这个就是我们在定义的时候接收的额外参数这个函数执行的时候会调用的回调函数并通过方法得到当前模块的和一起作为回调函数的参数我们知道是通过来触发的这里我们也来看一下的定义解析参数根据获取所有对应的处理过的函数集合执行函数执行所有的订阅者函数支持个参数表示的类型表示额外的参数根据去查找对应的如果找不到则输出一条错误信息否则遍历这个对应的对象数组执行方法这个方法就是之前定义的执行它就相当于执行了注册的回调函数辅助函数辅助函数的实现都差不太多在这里了解一下返回结果遍历规范化参数后的对象就是传递给的对象或者数组一般不会传入参数如果不存在则报错返回值可见上文的分析在调用了函数后把传入的转换成由对象构成的数组接着调用方法遍历这个数组构造一个新的对象这个新对象每个元素都返回一个新的函数函数对的类型判断如果是一个函数则直接调用这个函数把当前上的和作为参数返回值作为的返回值否则直接把作为的返回值为了更直观的理解我们看下最终的效果等同于和有什么区别参考答案更改的中的状态的唯一方法是提交中的非常类似于件每个都有一个字符串的事件类型和一个回调函数这个回调函数就是我们实际进行状态更改的地方并且它会接受作为第一个参数变更状态不能直接调用一个这个选项更像是事件注册当触发一个类型为的时调用此函数要唤醒一个你需要以相应的调用方法类似于不同在于提交的是而不是直接变更状态可以包含任意异步操作让我们来注册一个简单的扩展事实上在里面只是一个架构性的概念并不是必须的说到底只是一个函数你在里面想干嘛都可以只要最后触发就行异步竞态怎么处理那是用户自己的事情真正限制你的只有必须是同步的这一点在里面就好像必须同步返回下一个状态一样同步的意义在于这样每一个执行完成后都可以对应到一个新的状态和一样这样就可以打个存下来然后就可以随便了如果你开着调用一个异步的你可以清楚地看到它所调用的是何时被记录下来的并且可以立刻查看它们对应的状态修改样式的几种方式参考答案修改样式的方式有四种新建全局样式表新建文件并在中引入文件一般都放在静态资源文件夹下的文件夹下在的引用写法如下在文件中写的样式无论在哪一个单页面都会覆盖默认的样式在当前单页面中添加一个新的标签在当前的单页面的标签后添加一对新的标签新的标签中不要添加属性在有写的标签中书写的样式不会覆盖默认的样式使用深度修改标签样式找到需要修改的标签的类名然后在类名前加上可以强制修改默认样式这种方式可以直接用到有属性的标签中修改级联选择框的默认宽度通过内联样式或者绑定类样式覆盖默认样式通过内联样式绑定类样式的方式可以在某些标签中可以直接覆盖默认样式不是很通用具体实例如下默认按钮通过绑定修改样式方式修改默认按钮扩展第一种全局引入文件的方式适合于对整体的修改比如整体配色的修改第二种添加一个标签的形式也能够实现修改默认样式的效果但实际上因为是修改了全局的样式因此在不同的组件中修改同一个样式有可能会有冲突第三种方式通过的方式可以很方便的在组件中修改默认样式也不会于其他页面有冲突第四种方式局限性比较大可以使用但不推荐使用有什么用参考答案是一套采用作为基础框架实现的组件库一套为开发者设计师和产品经理准备的基于的组件库提供了配套设计资源帮助网站快速成型扩展特点一致性与现实生活一致与现实生活的流程逻辑保持一致遵循用户习惯的语言和概念在界面中一致所有的元素和结构需保持一致比如设计样式图标和文本元素的位置等反馈控制反馈通过界面样式和交互动效让用户可以清晰的感知自己的操作页面反馈操作后通过页面元素的变化清晰地展现当前状态效率简化流程设计简洁直观的操作流程清晰明确语言表达清晰且表意明确让用户快速理解进而作出决策帮助用户识别界面简单直白让用户快速识别而非回忆减少用户记忆负担可控用户决策根据场景可给予用户操作建议或安全提示但不能代替用户进行决策结果可控用户可以自由的进行操作包括撤销回退和终止当前操作等导航守卫参考答案导航守卫主要用来通过跳转或取消的方式守卫导航简单的说导航守卫就是路由跳转过程中的一些钩子函数路由跳转是一个大的过程这个大的过程分为跳转前中后等等细小的过程在每一个过程中都有一函数这个函数能让你操作一些其他的事儿的时机这就是导航守卫解析路由守卫的具体方法全局前置守卫你可以使用注册一个全局前置守卫当一个导航开始时全局前置守卫按照注册顺序调用守卫是异步链式调用的导航在最后的一层当中第一个全局前置守卫第二个全局前置守卫导航终于开始了导航在最后一层中每个守卫方法接收三个参数往后的守卫都大同小异即将要进入的目标路由对象当前导航正要离开的路由一定要调用该方法将控制权交给下一个守卫执行效果依赖方法的参数进入下一个守卫如果全部守卫执行完了则导航的状态就是确认的中断当前的导航把小明腿打断了如果浏览器的改变了可能是用户手动或者浏览器后退按钮那么地址会重置到路由对应的地址或者跳转到一个不同的地址当前的导航被中断然后进行一个新的导航小明被打断腿并且送回家了你可以向传递任意位置对象且允许设置诸如之类的选项以及任何用在的或中的选项如果传入的参数是一个实例则导航会被终止且该错误会被传递注册过的回调注意永远不要使用两次这会产生一些误会全局解析守卫这和类似但他总是被放在最后一个执行全局后置钩子导航已经确认了的小明已经到了外婆家了你打断他的腿他也是在外婆家了你并不能调用路由独享的守卫在路由内写的守卫组件内的守卫新增路由被前调用组件还未渲染出来不能获取组件实例在当前路由改变但是该组件被复用时调用举例来说对于一个带有动态参数的路径在和之间跳转的时候由于会渲染同样的组件因此组件实例会被复用而这个钩子就会在这个情况下被调用可以访问组件实例一般用来数据获取导航离开该组件的对应路由时调用可以访问组件实例扩展导航全过程导航被触发在准备离开的组件里调用守卫调用全局的守卫在重用的组件里调用守卫如果你的组件是重用的在路由配置里调用解析即将抵达的组件在即将抵达的组件里调用调用全局的守卫导航被确认调用全局的钩子触发更新用创建好的实例调用守卫中传给的回调函数路由守卫进行判断登录参考答案在项目中切换路由时肯定会碰到需要登录的路由其原理就是在切换路径之前进行判断你不可能进入页面再去判断有无登录重新定向到那样的话会导致页面已经渲染以及它的各种请求已经发出如需要登录的路由可在中统一处理全局前置守卫我们可以在入口文件里面进行配置使用方法不懂得可以打印的参数就可以随意换名的只要里面跟配置路由的里面的字段保持一致判断该路由是否需要登录权限将跳转的路由作为参数登录成功后跳转到该路由添加该字段表示进入这个路由是需要登录的全局后置守卫单独路由独享守卫与全局一致可单独对某个路由进行配置组件内部路由守卫可写在与生命周期同级位置在渲染该组件的对应路由被前调用不能获取组件实例因为当守卫执行前组件实例还没被创建在当前路由改变但是该组件被复用时调用举例来说对于一个带有动态参数的路径在和之间跳转的时候由于会渲染同样的组件因此组件实例会被复用而这个钩子就会在这个情况下被调用可以访问组件实例导航离开该组件的对应路由时调用可以访问组件实例实现懒加载参考答案懒加载当打包构建应用时包会变得非常大影响页面加载如果我们能把不同路由对应的组件分割成不同的代码块然后当路由被访问的时候才加载对应组件这样就更加高效了实现结合的异步组件和的代码分割功能可以实现路由组件的懒加载首先可以将异步组件定义为返回一个的工厂函数该函数返回的应该组件本身组件定义对象在中我们可以使用动态语法来定义代码分块点返回结合这两者这就是如何定义一个能够被自动代码分割的异步组件在路由配置中什么都不需要改变只需要像往常一样使用是如何监听的变化的参考答案通过浏览器的地址栏来改变切换页面前端实现主要有两种方式通过改变利用监听通过的改变进行操作加载页面然而并不像那样简单因为的改变除了浏览器的几个前进后退使用和方法来完成在用户历史记录中向后和向前的跳转等操作会主动触发事件并不会触发事件要解决监听的问题方法是首先完成一个订阅发布模式然后重写并添加消息通知这样一来只要的无法实现监听函数就被我们加上了事件通知只不过这里用的不是浏览器原生事件而是通过我们创建的来实现通知然后触发事件订阅函数的执行具体操作如下订阅发布模式示例订阅池这里简单的运用时间戳做订阅池的该事件下被订阅对象的集合添加订阅者通知订阅者有变化触发订阅者更新函数订阅消息的名称这里简单的运用时间戳做订阅者的订阅消息发送改变时订阅者执行的回调函数将订阅者放入订阅池将订阅者更新方法赋值为了不改变函数内调用的重写方法并添加事件机制置空供下一个订阅者使用和的区别和原理参考答案是官方的路由管理器它和的核心深度集成让构建单页面应用变得易如反掌默认模式还有一种是模式原理路由模式的工作原理是事件可以在监听的变化我们在后面随便添加一个触发这个事件默认的是模式使用的来模拟一个完整的于是当改变的时候页面不会重新加载也就是单页应用了当后面的发生变化不会导致浏览器向服务器发出请求浏览器不发出请求就不会刷新页面并且会触发这个事件通过监听值的变化来实现更新页面部分内容的操作对于模式会创建对象在访问不同的路由的时候会发生两件事将新的路由添加到浏览器访问的历史的栈顶和替换到当前栈顶的路由路由主要使用的和这两个结合事件监听浏览器前进后退来实现的可以改变地址且不会发送请求可以读取历史记录栈还可以对浏览器记录进行修改区别模式较丑模式较优雅设置的新可以是与当前同源的任意而只可修改后面的部分故只可设置与当前同文档的设置的新可以与当前一模一样这样也会把记录添加到栈中而设置的新值必须与原来不一样才会触发记录添加到栈中通过可以添加任意类型的数据到记录中而只可添加短字符串可额外设置属性供后续使用兼容以上兼容以上模式需要后端配合将所有访问都指向否则用户刷新页面会导致错误使用方法路由原理监听方法路由原理利用的的方法结合事件监听浏览器前进后退原理哪个模式不会请求服务器参考答案的两种方法模式不会请求服务器解析的就是通常所说的锚点通过事件来监听的变化以下需要轮询比如这个的值为它的特点在于虽然出现在中但不会被包括在请求中对后端完全没有影响因此改变不会重新加载页面的模式它使看起来像普通网站那样以分割没有单页面并没有跳转不过使用这种模式需要服务端支持服务端在接收到所有请求后都只想同一个文件不然会出现因此单页面应用只有一个整个网站的内容都在这一个里通过来处理组件通信的方式参考答案组件通信的方式的方式有以下种方法和这是最最常用的父子组件通信方式父组件向子组件传递数据是通过传递的子组件传递数据给父组件是通过触发事件来做到的第一种方式处理父子组件之间的数据传输有一个问题如果多层嵌套父组件下面有子组件组件下面有组件这时如果组件想传递数据给组件怎么办呢如果采用第一种方法我们必须让组件通过传递消息给组件组件在通过传递消息给组件要是组件和组件之间有更多的组件那采用这种方式就很复杂了从开始提供了来解决这个问题能够让组件之间传递消息给组件父组件通过传递值给子组件时会自动传递一个的属性在子组件中通过自动修改绑定的值和父组件中通过来提供变量然后在子组件中通过来注入变量不论子组件有多深只要调用了那么就可以注入中的数据而不是局限于只能从当前父组件的属性来获取数据只要在父组件的生命周期内子组件都可以调用中央事件总线上面方式都是处理的父子组件之间的数据传递那如果两个组件不是父子关系呢也就是兄弟组件如何通信这种情况下可以使用中央事件总线的方式新建一个事件对象然后通过监听触发的事件和和中提供了这种方式但中没有但很多开源软件都自己封装了这种方式比如和等比如如下代码一般都作为一个去使用是向特定的父组件触发事件是向特定的子组件触发事件本质上这种方式还是和和的封装但在一些基础组件中却很实用处理组件之间的数据交互如果业务逻辑复杂很多组件之间需要同时处理一些公共的数据这个时候才有上面这一些方法可能不利于项目的维护的做法就是将这一些公共的数据抽离出来然后其他组件就可以对这个公共数据进行读写操作这样达到了解耦的目的组件间传值和了解过吗参考答案的作用解决多层嵌套情况下父组件下面有子组件组件下面有组件组件传递数据给组件的问题这个方法是在提出的解决问题的过程组件触发父组件中的事件组件得到父组件传递过来的数据触发父组件中的事件组件这是来自组件的数据执行子组件触发的事件这是来自组件的数据解析组件中能直接触发的原因在于组件调用组件时使用绑定了属性通过绑定属性组件可以直接获取到组件中传递下来的除了组件中声明的组建传值事件总线是怎么用的参考答案中央事件总线主要用来解决兄弟组件通信的问题实现方式新建一个事件对象然后通过监听触发的事件触发全局事件传递过来的数据绑定全局事件中央事件总线生命周期中异步加载在还是里实现参考答案最常用的是在钩子函数中调用异步请求解析一般来说可以在中都可以发送数据请求但是大部分时候会在发送请求的使用场景如果页面首次渲染的就来自后端数据因为此时已经挂载到实例了在如果希望首次选的数据来自于后端就在此处发请求只发了异步请求渲染是在后端响应之后才进行的在中发请求会进行二次渲染这三个钩子函数中进行调用因为在这三个钩子函数中已经创建可以将服务端端返回的数据进行赋值但是最常用的是在钩子函数中调用异步请求因为在钩子函数中调用异步请求有两个优点第一点能更快获取到服务端数据减少页面时间第二点放在中有助于一致性因为不支持钩子函数钩子函数重点问了参考答案生命周期经历哪些阶段总体来说初始化运行中销毁详细来说开始创建初始化数据编译模板挂载渲染更新渲染销毁等一系列过程生命周期经历的阶段和钩子函数实例化组件对象初始化事件和生命周期和函数在实例初始化之后数据观测和事件配置之前被调用即此时组件对象被创建了但是对象的属性还没有绑定如属性属性还没有绑定即没有值此时还没有数据和真实即属性还没有赋值也没有动态创建属性对应的元素二阶段的函数还没有执行挂载数据属性赋值包括属性和的运算函数对象的属性有值了但是还没有生成属性还不存在此时有数据了但是还没有真实的即都执行了属性已经赋值但没有动态创建属性对应的元素所以此时如果更改数据不会触发函数如果数据的初始值就来自于后端可以发送或者请求获取数据但是此时不会触发函数检查检查是否有属性检查配置即里面的项是否存在有就继续检查项没有则等到手动绑定调用的绑定检查是否有属性检查配置中的项如果没有进行填充被绑定区域则被绑定区域的对即整个对象包括和标签都作为被填充对象替换掉填充区域即如果对象中有属性那么后面的会替换对应的内容如果有属性那么就会替换即优先关系时函数模板编译数据挂载把数据显示在模板里之前执行的钩子函数此时有值但是数据还没有挂载到页面上即此时页面中的里的变量还没有被数据替换模板编译用对象的数据属性替换模板中的内容函数模板编译完成数据挂载完毕即此时已经把数据挂载到了页面上所以页面上能够看到正确的数据了一般来说我们在此处发送异步请求等获取服务器上的数据显示在里函数组件更新之前执行的函数只有数据更新后才能调用触发注意此数据一定是在模板上出现的数据否则不会也没有必要触发组件更新因为数据不出现在模板里就没有必要再次渲染数据更新了但是组件对象对应的中的内部没有变所以叫作组件更新前函数组件更新之后执行的函数组件对象对应的中的内部改变了所以叫作组件更新之后函数组件激活时调用函数组件停用时调用组件对象销毁之前组件销毁后包裹动态组件时会缓存不活动的组件实例主要用于保留组件状态或避免重新渲染解析比如有一个列表和一个详情那么用户就会经常执行打开详情返回列表打开详情这样的话列表和详情都是一个频率很高的页面那么就可以对列表组件使用进行缓存这样用户每次返回列表的时候都能从缓存中快速渲染而不是重新渲染参考答案可以实现组件缓存是的一个内置组件作用它能够把不活动的组件实例保存在内存中而不是直接将其销毁它是一个抽象组件不会被渲染到真实中也不会出现在父组件链中使用方式常用的两个属性允许组件有条件的进行缓存两个生命周期用来得知当前组件是否处于活跃状态的中还运用了算法原理的缓存机制并不是直接存储结构而是将节点抽象成了一个个节点所以的缓存也是基于节点的而不是直接存储结构其实就是将需要缓存的节点保存在中在时如果的符合在缓存条件可以用以及控制则会从中取出之前缓存的实例进行渲染既然函数是引用类型为什么的还是可以用函数参考答案只有函数构成作用域注意理解作用域只有函数构成作用域对象的以及都不构成作用域是一个函数时每个组件实例都有自己的作用域每个实例相互独立不会相互影响中作用与原理参考答案作用是为了可以获取更新后的由于更新是异步执行的即修改数据时视图不会立即更新而是会监听数据变化并缓存在同一事件循环中等同一数据循环中的所有数据变化完成之后再统一进行视图更新为了确保得到更新后的所以设置了就是在下次更新循环结束之后执行延迟回调在修改数据之后立即使用这个方法获取更新后的原理在下次更新循环结束之后执行延迟回调主要使用了宏任务和微任务根据执行环境分别尝试采用如果以上都不行则采用定义了一个异步方法多次调用会将方法存入队列中通过这个异步方法清空当前队列的特性参考答案表单操作自定义指令计算属性过滤器侦听器生命周期区别参考答案和都是用来显示隐藏元素还有一个配合使用两者达到的效果都一样但是更消耗性能的因为在显示隐藏过程中有的添加和删除就简单多了只是操作解析不管条件是真还是假第一次渲染的时候都会编译出来也就是标签都会添加到中之后切换的时候通过样式来显示隐藏元素可以说只是改变的样式几乎不会影响什么性能在首次渲染的时候如果条件为假什么也不操作页面当作没有这些元素当条件为真的时候开始局部编译动态的向元素里面添加元素当条件从真变为假的时候开始局部编译卸载这些元素也就是删除列表为什么加参考答案中列表循环需加唯一标识唯一标识且最好是静态的因为组件高度复用增加可以标识组件的唯一性为了更好地区别各个组件的作用主要是为了高效的更新虚拟解析和的虚拟的算法大致相同其核心是基于两个简单的假设首先讲一下算法的处理方法对操作前后的树同一层的节点进行对比一层一层对比当某一层有很多相同的节点时也就是列表节点时算法的更新过程默认情况下也是遵循以上原则比如一下这个情况可以在和之间加一个算法默认执行起来是这样的即把更新成更新成更新成最后再插入是不是很没有效率所以我们需要使用来给每个节点做一个唯一标识算法就可以正确的识别此节点找到正确的位置区插入新的节点和相比参考答案轻量级的库前端库是一个精简的它专注于模型的层通过双向数据绑定把和层连接起来通过对数据的操作就可以完成对页面视图的渲染数据驱动视图思想数据视图完全分离数据驱动双向绑定直接操作获取修改赋值事件绑定操作简单操作麻烦模块化实现单页面组件复用性能高使用的虚拟减少的操作扩展适用的场景复杂数据操作的后台页面表单填写页面适用的场景比如说一些的动画页面一些需要来操作页面样式的页面二者也是可以结合起来一起使用的侧重数据绑定侧重样式操作动画效果等则会更加高效率的完成业务需求为什么选择用做页面展示参考答案框架正是使用了这种的框架形式并且通过声明式渲染和响应式数据绑定的方式来帮助我们完全避免了对的操作单页面应用程序配合生态圈中的就可以非常方便的开发复杂的单页应用轻量化与易学习的生产版本只有的大小几乎不会对我们的网页加载速度产生影响同时因为只专注于视图层单独的就像一个库一样所以使我们的学习成本变得非常低渐进式与兼容性的核心库只关注视图层不仅易于上手还便于与第三方库或既有项目整合只做界面而把其他的一切都交给了它的周边生态官方推荐等来做处理这就要求必须要对其他的框架拥有最大程度的兼容性视图组件化允许通过组件来去拼装一个页面每个组件都是一个可复用的实例组件里面可以包含自己的数据视图和代码逻辑方便复用虚拟之所以可以完全避免对的操作就是因为采用了虚拟的方式不但避免了我们对的复杂操作并且大大的加快了我们应用的运行速度社区支持得益于的本土化身份的作者为国人尤雨溪再加上本身的强大所以涌现出了特别多的国内社区这种情况在其他的框架身上是没有出现过的这使得我们在学习或者使用的时候可以获得更多的帮助未来的走向是由国人尤雨溪在工作的时候为了方便自己的工作而开发出来的一个库而在被使用的过程中突然发现越来越多的人喜欢上了它所以尤雨溪就进入了一个边工作边维护的状态在这种情况下依然迅速的发展而现在尤雨溪已经正式辞去了的工作开始专职维护同时加入进来的还有几十位优秀的开发者他们致力于把打造为最受欢迎的前端框架事实证明确实在往越来越好的方向发展了从的对比图中可以看出的势头所以我觉得完全不需要担心未来的发展至少在没有新的颠覆性创新出来之前都会越做越好区别参考答案体积和性能相较于显得比较臃肿比如一个包含了的项目之后而生成的默认项目尺寸还是要小得多在性能上依赖对数据做脏检查所以越多越慢使用基于依赖追踪的观察并且使用异步队列更新所有的数据都是独立触发的对于庞大的应用来说这个优化差异还是比较明显的在底层渲染方面使用的虚拟而使用的是的优势在于低内开销相比于更加灵活可以按照不同的需要去组织项目的应用代码比如甚至可以直接像引用那样在中引用然后仅仅当成一个前端的模板引擎来用支持是新一代的标准对进行了大量的改进使用开发已是基本需求虽然有部分十分老旧的浏览器不支持但是可以利用现代开发工具将编译成在对的支持上两者都做得很好本身就是的超集学习曲线针对前端而言的学习曲线相对较大学习起来更容易一些不过对和的使用者而言的静态检查依赖注入的特性以及面向对象的编程风格使得都要更亲切一些使用热度在使用热度上具有更大优势主要原因是更受数量庞大的中国开发者欢迎较低的上手难度易懂的开发文档以及国人主导开发的光环都使得更为流行双向数据绑定原理参考答案目前几种主流的框架都实现了单向数据绑定而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素等添加了事件来动态修改和并没有多高深所以无需太过介怀是实现的单向或双向绑定实现数据绑定的做法有大致如下几种发布者订阅者模式一般通过的方式实现数据和视图的绑定监听更新数据方式通常做法是这种方式现在毕竟太了我们更希望通过这种方式更新数据同时自动更新视图于是有了下面两种方式脏值检查是通过脏值检测的方式比对数据是否有变更来决定是否更新视图最简单的方式就是通过定时轮询检测数据变动当然不会这么只有在指定的事件触发时进入脏值检测大致如下事件譬如用户输入文本点击按钮等响应事件浏览器变更事件事件执行或数据劫持则是采用数据劫持结合发布者订阅者模式的方式通过来劫持各个属性的在数据变动时发布消息给订阅者触发相应的监听回调既然通过数据劫持可以精准探测数据在具体上的变化为什么还需要虚拟呢参考答案前置知识依赖收集虚拟响应式系统现代前端框架有两种方式侦测变化一种是一种是其代表为我们可以回忆一下是如何侦测到变化的我们通常会用显式更新然后会进行一层层的操作找出差异然后到上从一开始就不知道到底是哪发生了变化只是知道有变化了然后再进行比较暴力的操作查找哪发生变化了另外一个代表就是的脏检查操作的响应式系统则是的代表当程序初始化的时候就会对数据进行依赖的收集一但数据发生变化响应式系统就会立刻得知因此是一开始就知道是在哪发生变化了但是这又会产生一个问题如果你熟悉的响应式系统就知道通常一个绑定一个数据就需要一个一但我们的绑定细粒度过高就会产生大量的这会带来内存以及依赖追踪的开销而细粒度过低会无法精准侦测变化因此的设计是选择中等细粒度的方案在组件级别进行侦测的方式也就是那套响应式系统通常我们会第一时间侦测到发生变化的组件然后在组件内部进行获取更加具体的差异而则是操作是结合的方式进行变化侦测的简单聊聊以后发生的事情参考答案会调用原型链上的方法对实例进行初始化首先是初始化生命周期对实例内部的一些属性如进行初始化初始化当前实例上的一些自定义事件解析绑定在实例上绑定方法在实例上完成对生命周期自定义事件等一系列属性的初始化后触发生命周期钩子在初始化和之前完成依赖注入类似于完成对和的初始化同时对属性完成数据劫持内部启用监听者对数据进行监听更改对依赖注入进行解析完成对数据状态的初始化后触发生命周期钩子进入挂载阶段将模板语法通过解析成虚拟树虚拟树与数据完成双向绑定触发生命周期钩子将解析好的虚拟树通过渲染成真实触发生命周期钩子中的的理解参考答案需要使用来给每个节点做一个唯一标识算法就可以正确的识别此节点主要是为了高效的更新虚拟首屏白屏如何解决参考答案路由懒加载开启打包压缩和后台配合访问进行加速开启服务渲染模式用的属性把不需要打包的库文件分离出去减少打包后文件的大小在生产环境中删除掉不必要的添加删除开启的在配置文件中配置在中配置如下代码压缩级别不压缩临界值添加效果给用户一种进度感受单页面和传统的多页面区别参考答案单页面应用通俗一点说就是指只有一个主页面的应用浏览器一开始要加载所有必须的所有的页面内容都包含在这个所谓的主页面中但在写的时候还是会分开写页面片段然后在交互的时候由路由程序动态载入单页面的页面跳转仅刷新局部资源多应用于端多页面指一个应用中有多个页面页面跳转时是整页刷新单页面的优点用户体验好快内容的改变不需要重新加载整个页面基于这一点对服务器压力较小前后端分离页面效果会比较炫酷比如切换页面内容时的专场动画单页面缺点不利于导航不可用如果一定要导航需要自行实现前进后退由于是单页面不能用浏览器的前进后退功能所以需要自己建立堆栈管理初次加载时耗时多页面复杂度提高很多的使用参考答案可以用来获取的根实例比如在简单的项目中将公共数据放再根实例上可以理解为一个全局因此可以代替实现状态管理在子组件上使用特性后属性可以直接访问该子组件可以代替事件和获取指定元素注意属性可以用来从一个子组件访问父组件的实例可以替代将数据以的方式传入子组件的方式当变更父级组件的数据的时候容易造成调试和理解难度增加路由跳转和的区别参考答案使用来跳转简单方便但是刷新了页面使用路由方式跳转无刷新页面静态跳转是什么在中的安装使用步骤是有哪几大特性参考答案的预编译使用步骤先装等加载器模块在目录找到在那个属性中加一个拓展在同一个文件配置一个属性然后在组件的标签加上属性例如特性可以用变量例如变量名称值可以用混合器例如可以嵌套与区别会删除数组的值但是它依然会在内存中占位置而会删除数组在内存中的占位和的区别参考答案计算结果并返回只有当被计算的属性发生改变时才会触发即计算属性的结果会被缓存除非依赖的响应属性变化才会重新及孙监听某一个值当被监听的值发生变化时执行相关操作与的区别是更加适用于监听某一个值得变化并做对应操作比如请求后太接口等而适用于计算已有的值并返回结果监听简单数据类型为什么要用解决对象新增属性不能响应的问题你能说说如下代码的实现原理么参考答案为什么要用解决对象新增属性不能响应的问题使用了实现双向数据绑定在初始化实例时对属性执行转化属性必须在对象上存在才能让将它转换为响应式的这也就造成了无法检测到对象属性的添加或删除所以提供了框架本身是如何实现的呢源码位置为数组修改数组的长度避免索引数组长度导致执行有误利用数组的变异方法触发响应式已经存在直接修改属性值本身就不是响应式数据直接赋值对属性进行响应式处理我们阅读以上源码可知的实现原理是如果目标是数组直接使用数组的方法触发相应式如果目标是对象会先判读属性是否存在对象是否是响应式最终如果要对属性进行响应式处理则是通过调用方法进行响应式处理',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-03 12:55:57',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="你别睡这么晚！" type="application/atom+xml">
</head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://avatars.githubusercontent.com/u/47170023?v=4"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://dont-sleep-so-late.github.io/" title="博客"><img class="back-menu-item-icon" src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">你别睡这么晚！</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=150767257&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/wechatQRCode.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/wechatQRCode.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/qqQRCode.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/qqQRCode.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">API文档管理<sup>1</sup></a><a href="/tags/Array/" style="font-size: 1.05rem;">Array<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 1.05rem;">CSS<sup>4</sup></a><a href="/tags/CSS-Less/" style="font-size: 1.05rem;">CSS Less<sup>1</sup></a><a href="/tags/CSS-flex/" style="font-size: 1.05rem;">CSS flex<sup>1</sup></a><a href="/tags/CSS-grid/" style="font-size: 1.05rem;">CSS grid<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 1.05rem;">ES6<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 1.05rem;">HTML<sup>2</sup></a><a href="/tags/HTML5/" style="font-size: 1.05rem;">HTML5<sup>1</sup></a><a href="/tags/HTTP/" style="font-size: 1.05rem;">HTTP<sup>1</sup></a><a href="/tags/JS-array/" style="font-size: 1.05rem;">JS array<sup>1</sup></a><a href="/tags/JS-%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 1.05rem;">JS 模块化<sup>1</sup></a><a href="/tags/JavaSciprt/" style="font-size: 1.05rem;">JavaSciprt<sup>2</sup></a><a href="/tags/JavaScript/" style="font-size: 1.05rem;">JavaScript<sup>7</sup></a><a href="/tags/Mybatis/" style="font-size: 1.05rem;">Mybatis<sup>2</sup></a><a href="/tags/MybatisPlus/" style="font-size: 1.05rem;">MybatisPlus<sup>1</sup></a><a href="/tags/OpenAPI-Swagger/" style="font-size: 1.05rem;">OpenAPI/Swagger<sup>1</sup></a><a href="/tags/Router/" style="font-size: 1.05rem;">Router<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 1.05rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringMVC/" style="font-size: 1.05rem;">SpringMVC<sup>1</sup></a><a href="/tags/TCP/" style="font-size: 1.05rem;">TCP<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 1.05rem;">Vue<sup>18</sup></a><a href="/tags/Vue3/" style="font-size: 1.05rem;">Vue3<sup>5</sup></a><a href="/tags/Vuex/" style="font-size: 1.05rem;">Vuex<sup>1</sup></a><a href="/tags/Vue%E6%8F%92%E4%BB%B6/" style="font-size: 1.05rem;">Vue插件<sup>1</sup></a><a href="/tags/Vue%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" style="font-size: 1.05rem;">Vue核心基础<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6/" style="font-size: 1.05rem;">Vue组件<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">Vue组件化编程<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/" style="font-size: 1.05rem;">Vue组件间通信<sup>1</sup></a><a href="/tags/Vue%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 1.05rem;">Vue网络请求<sup>1</sup></a><a href="/tags/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/" style="font-size: 1.05rem;">Vue脚手架<sup>1</sup></a><a href="/tags/css/" style="font-size: 1.05rem;">css<sup>1</sup></a><a href="/tags/sass/" style="font-size: 1.05rem;">sass<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.05rem;">前端开发<sup>1</sup></a><a href="/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 1.05rem;">实用技巧<sup>1</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 1.05rem;">微信小程序<sup>5</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 1.05rem;">正则表达式<sup>1</sup></a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/" style="font-size: 1.05rem;">浏览器知识<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/" style="font-size: 1.05rem;">网站推荐<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/10/"><span class="card-archive-list-date">十月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">45</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item on" id="consoleCommentBarrage" onclick="anzhiyu.switchCommentBarrage()" title="热评开关"><a class="commentBarrage"><i class="anzhiyufont anzhiyu-icon-message"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/Vue/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>Vue</span></a><a class="article-meta__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>八股文</span></a></span></div></div><h1 class="post-title" itemprop="name headline">Vue八股文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-03-07T15:31:36.000Z" title="发表于 2024-03-07 23:31:36">2024-03-07</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-04-03T04:55:57.157Z" title="更新于 2024-04-03 12:55:57">2024-04-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">17.7k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>62分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="Vue八股文"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为湛江"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>湛江</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src=""></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/"><header><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" itemprop="url">前端开发</a><a href="/tags/Vue/" tabindex="-1" itemprop="url">Vue</a><a href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" tabindex="-1" itemprop="url">八股文</a><h1 id="CrawlerTitle" itemprop="name headline">Vue八股文</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">你别睡这么晚</span><time itemprop="dateCreated datePublished" datetime="2024-03-07T15:31:36.000Z" title="发表于 2024-03-07 23:31:36">2024-03-07</time><time itemprop="dateCreated datePublished" datetime="2024-04-03T04:55:57.157Z" title="更新于 2024-04-03 12:55:57">2024-04-03</time></header><h2 id="Vue-的设计模式"><a href="#Vue-的设计模式" class="headerlink" title="Vue 的设计模式"></a>Vue 的设计模式</h2><h3 id="介绍一下-MVVM-模式，和-MVC-模式有什么区别？"><a href="#介绍一下-MVVM-模式，和-MVC-模式有什么区别？" class="headerlink" title="介绍一下 MVVM 模式，和 MVC 模式有什么区别？"></a>介绍一下 MVVM 模式，和 MVC 模式有什么区别？</h3><p>MVVM 即 Model-View-ViewModel 的简写，即模型-视图-视图模型。模型（Model）指的是后端传递的数据。视图（View）指的是所看到的页面。视图模型（ViewModel）是 MVVM 模式的核心，它是连接 View 和 Model 的桥梁。<br>视图模型有两个方向的作用：<br>1.将模型（Model）转化成视图（View），即将后端传递的数据转化成所看到的页面，实现的方式是：数据绑定。<br>2.将视图（View）转化成模型（Model），即将所看到的页面转化成后端的数据，实现的方式是：DOM 事件监听。当这两个方向的数据转换都实现时，我们称之为数据的双向绑定。</p>
<p><strong>MVVM模型图解：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.leetcode.cn/1677830973-gNoWGQ-image.png"></p>
<p>MVC 是 Model-View-Controller 的简写，即模型-视图-控制器。M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。C 即 Controller 指的是页面业务逻辑。使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信，也就是 View 跟 Model ，必须通过 Controller 来承上启下。</p>
<p><strong>MVC模型图解：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://pic.leetcode.cn/1677830876-FXzrYJ-image.png"></p>
<p>MVVM 与 MVC 最大的区别就是：MVVM 实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（双向绑定）。</p>
<hr>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="Vue2-的生命周期有哪些"><a href="#Vue2-的生命周期有哪些" class="headerlink" title="Vue2 的生命周期有哪些"></a>Vue2 的生命周期有哪些</h3><p>生命周期可以理解为三部分，第一部分为初始化 Vue 实例的过程，第二部分为数据渲染，更新 Dom 的过程，第三部分为销毁实例的过程，每一个部分都有对应的钩子函数来完成对应的部分过程。</p>
<p>初始化阶段的钩子函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeCreate</span>()<span class="comment">//实例创建前：模板和数据均未获取到</span></span><br><span class="line"><span class="title function_">created</span>()<span class="comment">//实例创建后：最早可以获得data数据，但模板还未获取到</span></span><br><span class="line"><span class="title function_">beforfeMount</span>()<span class="comment">//数据挂载前：模板已经获取到，但是数据未挂载到模板上</span></span><br><span class="line"><span class="title function_">mounted</span>()<span class="comment">//数据挂载后：数据已挂载到模板中</span></span><br></pre></td></tr></table></figure>

<p>更新阶段的钩子函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">beforeUpdate()//模板更新前：data改变后，更新数据模板前调用 </span><br><span class="line">updated()//模板更新后：将data渲染到数据模板中</span><br></pre></td></tr></table></figure>

<p>销毁阶段的钩子函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">beforeDestroy</span>() <span class="comment">//实例销毁前 </span></span><br><span class="line"><span class="title function_">destroyed</span>() <span class="comment">//实例销毁后</span></span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/20240307234024.png"></p>
<h3 id="keep-alive-中的生命周期有哪些"><a href="#keep-alive-中的生命周期有哪些" class="headerlink" title="keep-alive 中的生命周期有哪些"></a>keep-alive 中的生命周期有哪些</h3><p>keep-alive 是 Vue 提供的一个内置组件，用来对组件进行缓存，在组件切换过程中将状态保留在内存中，防止重复渲染 DOM。 如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。 当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期； 当组件被切回来时，再去缓存里找这个组件、触发 activated 钩子函数。</p>
<h3 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="headerlink" title="父子组件生命周期执行顺序"></a>父子组件生命周期执行顺序</h3><h4 id="1-挂载阶段"><a href="#1-挂载阶段" class="headerlink" title="1.挂载阶段"></a>1.挂载阶段</h4><p>该过程主要涉及 beforeCreate、created、beforeMount、mounted 4 个钩子函数。执行顺序为：<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p>
<p>一定得等子组件挂载完毕后，父组件才能挂在完毕，所以父组件的 mounted 在最后。</p>
<h4 id="2-更新阶段"><a href="#2-更新阶段" class="headerlink" title="2.更新阶段"></a>2.更新阶段</h4><p>该过程主要涉及 beforeUpdate、updated 2 个钩子函数。注意，当父子组件有数据传递时，才有这个更新阶段执行顺序的比较。执行顺序为：</p>
<p>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p>
<h4 id="3-销毁阶段"><a href="#3-销毁阶段" class="headerlink" title="3.销毁阶段"></a>3.销毁阶段</h4><p>该过程主要涉及beforeDestroy、destroyed 2 个钩子函数。执行顺序为：<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1.当父组件执行完 beforeMount 挂载开始后，会依次执行子组件中的钩子，直到全部子组件 mounted 挂载到实例上，父组件才会进入 mounted 钩子</p>
<p>2.子级触发事件，会先触发父级 beforeUpdate 钩子，再去触发子级 beforeUpdate 钩子，下面又是先执行子级 updated 钩子，后执行父级 updated 钩子</p>
<h3 id="平时发送异步请求在哪个生命周期，并解释原因"><a href="#平时发送异步请求在哪个生命周期，并解释原因" class="headerlink" title="平时发送异步请求在哪个生命周期，并解释原因"></a>平时发送异步请求在哪个生命周期，并解释原因</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：能更快获取到服务端数据，减少页面加载时间，用户体验更好；SSR 不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</p>
<h4 id="【延伸问答】created-和-mouted-区别"><a href="#【延伸问答】created-和-mouted-区别" class="headerlink" title="【延伸问答】created 和 mouted 区别"></a>【延伸问答】created 和 mouted 区别</h4><p>created 生命周期钩子函数会在组件实例被创建之后立即调用，但是此时组件的模板还没有被渲染成 HTML，因此在这个时候不能访问组件中的 DOM 元素。</p>
<p>mounted 生命周期钩子函数则会在组件的模板被渲染成 HTML 之后调用，这个时候可以访问组件中的 DOM 元素。通常在这个钩子函数中进行异步请求数据、初始化插件、订阅事件等操作。</p>
<p>总之，created 钩子函数适用于组件初始化时需要进行一些操作，而 mounted 钩子函数适用于需要操作组件的 DOM 元素时。</p>
<h2 id="1-Vue面试题"><a href="#1-Vue面试题" class="headerlink" title="1. Vue面试题"></a>1. Vue面试题</h2><h4 id="1-1-v-model-作用？"><a href="#1-1-v-model-作用？" class="headerlink" title="1.1 v-model 作用？"></a>1.1 v-model 作用？</h4><p><strong>参考答案：</strong></p>
<p>v-model本质上不过是语法糖，可以用 v-model 指令在<strong>表单</strong>及<strong>元素</strong>上创建双向数据绑定。</p>
<ol>
<li>它会根据控件类型自动选取正确的方法来更新元素</li>
<li>它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理</li>
<li>v-model会忽略所有表单元素的value、checked、selected特性的初始值,而总是将 Vue 实例的数据作为数据来源，因此我们应该通过 JavaScript 在组件的data选项中声明初始值</li>
</ol>
<p><strong>扩展：</strong></p>
<p>v-model在内部为不同的输入元素使用不同的属性并抛出不同的事件：</p>
<ol>
<li>text 和 textarea 元素使用value属性和input事件；</li>
<li>checkbox 和 radio 使用checked属性和change事件；</li>
<li>select 字段将value作为 prop 并将change作为事件。</li>
</ol>
<h4 id="1-2-v-model-实现原理？"><a href="#1-2-v-model-实现原理？" class="headerlink" title="1.2 v-model 实现原理？"></a>1.2 v-model 实现原理？</h4><p><strong>参考答案：</strong></p>
<p>v-model只不过是一个语法糖而已,真正的实现靠的还是</p>
<ol>
<li>v-bind:绑定响应式数据</li>
<li>触发oninput 事件并传递数据</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;sth&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 等同于--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">:value</span>=<span class="string">&quot;sth&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;sth = $event.target.value&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自html5开始,input每次输入都会触发oninput事件，所以输入时input的内容会绑定到sth中，于是sth的值就被改变--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event 指代当前触发的事件对象;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target 指代当前触发的事件对象的dom;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--$event.target.value 就是当前dom的value值;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在@input方法中，value =&gt; sth;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在:value中,sth =&gt; value;--&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-Vue2-0-双向绑定的缺陷？"><a href="#1-3-Vue2-0-双向绑定的缺陷？" class="headerlink" title="1.3 Vue2.0 双向绑定的缺陷？"></a>1.3 Vue2.0 双向绑定的缺陷？</h4><p><strong>参考答案：</strong></p>
<p>Vue2.0的数据响应是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty () 来劫持各个属性的setter、getter，但是它并不算是实现数据的响应式的完美方案，某些情况下需要对其进行修补或者hack这也是它的缺陷，主要表现在两个方面：</p>
<ol>
<li>vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改<ol>
<li>不能监听数组的变化</li>
</ol>
</li>
</ol>
<p><strong>解析：</strong></p>
<ol>
<li><p>vue 实例创建后，无法检测到对象属性的新增或删除，只能追踪到数据是否被修改(Object.defineProperty只能劫持对象的属性)。</p>
<p>当创建一个Vue实例时，将遍历所有DOM对象，并为每个数据属性添加了get和set。get和set 允许Vue观察数据的更改并触发更新。但是，如果你在Vue实例化后添加（或删除）一个属性，这个属性不会被vue处理，改变get和set。</p>
<p>解决方案：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">set</span>(obj, propertName/index, value)</span><br><span class="line"><span class="comment">// 响应式对象的子对象新增属性，可以给子响应式对象重新赋值</span></span><br><span class="line">data.<span class="property">location</span> = &#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">y</span>: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">data.<span class="property">location</span> = &#123;...data, <span class="attr">z</span>: <span class="number">100</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能监听数组的变化</p>
<p>vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响应式，这也只限制在数组的push&#x2F;pop&#x2F;shift&#x2F;unshift&#x2F;splice&#x2F;sort&#x2F;reverse七个方法，其他数组方法及数组的使用则无法检测到，例如如下两种使用方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.<span class="property">items</span>[index] = newValue;</span><br><span class="line">vm.<span class="property">items</span>.<span class="property">length</span></span><br></pre></td></tr></table></figure>

<p>vue实现数组响应式的方法</p>
<p>通过重写数组的Array.prototype对应的方法，具体来说就是重新指定要操作数组的prototype，并重新该prototype中对应上面的7个数组方法，通过下面代码简单了解下实现原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> methods = [<span class="string">&#x27;pop&#x27;</span>,<span class="string">&#x27;shift&#x27;</span>,<span class="string">&#x27;unshift&#x27;</span>,<span class="string">&#x27;sort&#x27;</span>,<span class="string">&#x27;reverse&#x27;</span>,<span class="string">&#x27;splice&#x27;</span>, <span class="string">&#x27;push&#x27;</span>];</span><br><span class="line"><span class="comment">// 复制Array.prototype，并将其prototype指向Array.prototype</span></span><br><span class="line"><span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">methods.<span class="title function_">forEach</span>(<span class="function"><span class="params">method</span> =&gt;</span> &#123;</span><br><span class="line">    proto[method] = <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">// 重写proto中的数组方法</span></span><br><span class="line">        <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>[method].<span class="title function_">call</span>(<span class="variable language_">this</span>, ...<span class="variable language_">arguments</span>);</span><br><span class="line">        <span class="title function_">viewRender</span>() <span class="comment">// 视图更新</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">observe</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj)) &#123; <span class="comment">// 数组实现响应式</span></span><br><span class="line">                obj.<span class="property">__proto__</span> = proto; <span class="comment">// 改变传入数组的prototype</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">                ... <span class="comment">// 对象的响应式实现</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-4-Vue3-0-实现数据双向绑定的方法"><a href="#1-4-Vue3-0-实现数据双向绑定的方法" class="headerlink" title="1.4 Vue3.0 实现数据双向绑定的方法"></a>1.4 Vue3.0 实现数据双向绑定的方法</h4><p><strong>参考答案:</strong></p>
<p>vue3.0 实现数据双向绑定是通过<strong>Proxy</strong></p>
<p><strong>Proxy</strong>是 ES6 中新增的一个特性，翻译过来意思是”代理”，用在这里表示由它来“代理”某些操作。 Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。</p>
<p>使用 Proxy 的核心优点是可以交由它来处理一些非核心逻辑（如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）。 从而可以让对象只需关注于核心逻辑，达到关注点分离，降低对象复杂度等目的。</p>
<p><strong>扩展：</strong></p>
<p>使用proxy实现，双向数据绑定，相比2.0的Object.defineProperty ()优势：</p>
<ol>
<li>可以劫持整个对象，并返回一个新对象</li>
<li>有13种劫持操作</li>
</ol>
<h4 id="1-5-Vuex是什么，每个属性是干嘛的，如何使用"><a href="#1-5-Vuex是什么，每个属性是干嘛的，如何使用" class="headerlink" title="1.5 Vuex是什么，每个属性是干嘛的，如何使用"></a>1.5 Vuex是什么，每个属性是干嘛的，如何使用</h4><p><strong>参考答案：</strong></p>
<p>Vuex是什么？</p>
<p>Vuex是专门为Vuejs应用程序设计的<strong>状态管理工具</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化</p>
<p>具体工作：vuex是一种状态管理机制，将全局组件的共享状态抽取出来为一个store，以一个单例模式存在，应用任何一个组件中都可以使用，vuex更改state的唯一途径是通过mutation，mutation需要commit触发, action实际触发是mutation，其中mutation处理同步任务，action处理异步任务。</p>
<p>Vuex每个属性是干嘛的？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128565972/EB5115B586566907B3B642BA58A4482A" alt="img"></p>
<p>Vuex的属性包含以下6个：</p>
<p>1）state</p>
<p>state是存储的单一状态，是存储的基本数据。</p>
<p>2）Getters</p>
<p>getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。</p>
<p>3）Mutations</p>
<p>mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）</p>
<p>4）Actions</p>
<p>actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）</p>
<p>5）Module</p>
<p>Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.<span class="property">state</span>.<span class="property">a</span> <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.<span class="property">state</span>.<span class="property">b</span> <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<p>6）辅助函数</p>
<p>Vuex提供了mapState、MapGetters、MapActions、mapMutations等辅助函数给开发在vm中处理store。</p>
<p>Vuex的使用方法？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128588464/5ACC9FABB642EADBED3478A9397CEF15" alt="img"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>); <span class="comment">// 1. vue的插件机制，安装vuex</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123; <span class="comment">// 2.实例化store，调用install方法</span></span><br><span class="line">    state,</span><br><span class="line">    getters,</span><br><span class="line">    modules,</span><br><span class="line">    mutations,</span><br><span class="line">    actions,</span><br><span class="line">    plugins</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; <span class="comment">// 3.注入store, 挂载vue实例</span></span><br><span class="line">    store,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span>=&gt;</span><span class="title function_">h</span>(app)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-6-Vuex实现原理"><a href="#1-6-Vuex实现原理" class="headerlink" title="1.6 Vuex实现原理"></a>1.6 Vuex实现原理</h4><p><strong>参考答案：</strong></p>
<p>通过以下三个方面来阐述vuex的实现原理：</p>
<ul>
<li>store是怎么注册的?</li>
<li>mutation，commit 是怎么实现的?</li>
<li>辅助函数是怎么实现的?</li>
</ul>
<ol>
<li><p>store是怎么注册的?</p>
<p>我们看到Vuex在vue 的生命周期中的初始化钩子前插入一段 Vuex 初始化代码。给 Vue 的实例注入一个</p>
<p>$store的属性，这也就是为什么我们在 Vue 的组件中可以通过this.$store.xxx, 访问到 Vuex 的各种数据和状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params">Vue</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取当前 Vue 的版本</span></span><br><span class="line">  <span class="keyword">const</span> version = <span class="title class_">Number</span>(<span class="title class_">Vue</span>.<span class="property">version</span>.<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (version &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.x 通过 hook 的方式注入</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123; <span class="attr">beforeCreate</span>: vuexInit &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 兼容 1.x</span></span><br><span class="line">    <span class="comment">// 使用自定义的 _init 方法并替换 Vue 对象原型的_init方法，实现注入</span></span><br><span class="line">    <span class="keyword">const</span> _init = <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">_init</span> = <span class="keyword">function</span> (<span class="params">options = &#123;&#125;</span>) &#123;</span><br><span class="line">      options.<span class="property">init</span> = options.<span class="property">init</span></span><br><span class="line">        ? [vuexInit].<span class="title function_">concat</span>(options.<span class="property">init</span>)</span><br><span class="line">        : vuexInit</span><br><span class="line">      _init.<span class="title function_">call</span>(<span class="variable language_">this</span>, options)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Vuex init hook, injected into each instances init hooks list.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">vuexInit</span> () &#123;</span><br><span class="line">    <span class="keyword">const</span> options = <span class="variable language_">this</span>.<span class="property">$options</span></span><br><span class="line">    <span class="comment">// store 注入</span></span><br><span class="line">    <span class="keyword">if</span> (options.<span class="property">store</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span> = <span class="keyword">typeof</span> options.<span class="property">store</span> === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">        ? options.<span class="title function_">store</span>()</span><br><span class="line">        : options.<span class="property">store</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options.<span class="property">parent</span> &amp;&amp; options.<span class="property">parent</span>.<span class="property">$store</span>) &#123;</span><br><span class="line">      <span class="comment">// 子组件从其父组件引用 $store 属性</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">$store</span> = options.<span class="property">parent</span>.<span class="property">$store</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>mutations，commit 是怎么实现的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">registerMutation</span> (store, type, handler, local) &#123;</span><br><span class="line">  <span class="comment">// 获取 type(module.mutations 的 key) 对应的 mutations, 没有就创建一个空数组</span></span><br><span class="line">  <span class="keyword">const</span> entry = store.<span class="property">_mutations</span>[type] || (store.<span class="property">_mutations</span>[type] = [])</span><br><span class="line">  <span class="comment">// push 处理过的 mutation handler</span></span><br><span class="line">  entry.<span class="title function_">push</span>(<span class="keyword">function</span> <span class="title function_">wrappedMutationHandler</span> (payload) &#123;</span><br><span class="line">    <span class="comment">// 调用用户定义的 hanler, 并传入 state 和 payload 参数</span></span><br><span class="line">    handler.<span class="title function_">call</span>(store, local.<span class="property">state</span>, payload)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerMutation 是对 store 的 mutation 的初始化，它接受 4 个参数，store为当前 Store 实例，type为 mutation 的 key，handler 为 mutation 执行的回调函数，path 为当前模块的路径。</p>
<p>mutation 的作用就是同步修改当前模块的 state ，函数首先通过 type 拿到对应的 mutation 对象数组， 然后把一个 mutation 的包装函数 push 到这个数组中，这个函数接收一个参数 payload，这个就是我们在定义 mutation 的时候接收的额外参数。这个函数执行的时候会调用 mutation 的回调函数，并通过 getNestedState(store.state, path) 方法得到当前模块的 state，和 playload 一起作为回调函数的参数。</p>
<p>我们知道mutation是通过commit来触发的，这里我们也来看一下commit的定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">commit (_type, _payload, _options) &#123;</span><br><span class="line">    <span class="comment">// 解析参数</span></span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      type,</span><br><span class="line">      payload,</span><br><span class="line">      options</span><br><span class="line">    &#125; = <span class="title function_">unifyObjectStyle</span>(_type, _payload, _options)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 type 获取所有对应的处理过的 mutation 函数集合</span></span><br><span class="line">    <span class="keyword">const</span> mutation = &#123; type, payload &#125;</span><br><span class="line">    <span class="keyword">const</span> entry = <span class="variable language_">this</span>.<span class="property">_mutations</span>[type]</span><br><span class="line">    <span class="keyword">if</span> (!entry) &#123;</span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[vuex] unknown mutation type: <span class="subst">$&#123;type&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 mutation 函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">_withCommit</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      entry.<span class="title function_">forEach</span>(<span class="keyword">function</span> <span class="title function_">commitIterator</span> (handler) &#123;</span><br><span class="line">        <span class="title function_">handler</span>(payload)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行所有的订阅者函数</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">_subscribers</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">sub</span> =&gt;</span> <span class="title function_">sub</span>(mutation, <span class="variable language_">this</span>.<span class="property">state</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      options &amp;&amp; options.<span class="property">silent</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">warn</span>(</span><br><span class="line">    <span class="string">`[vuex] mutation type: <span class="subst">$&#123;type&#125;</span>. Silent option has been removed. `</span> +</span><br><span class="line">        <span class="string">&#x27;Use the filter functionality in the vue-devtools&#x27;</span></span><br><span class="line">  )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>commit 支持 3 个参数，type 表示 mutation 的类型，payload 表示额外的参数,根据 type 去查找对应的 mutation，如果找不到，则输出一条错误信息，否则遍历这个 type 对应的 mutation 对象数组，执行 handler(payload) 方法，这个方法就是之前定义的 wrappedMutationHandler(handler)，执行它就相当于执行了 registerMutation 注册的回调函数。</p>
</li>
<li><p>辅助函数</p>
<p>辅助函数的实现都差不太多，在这里了解一下mapState</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mapGetters = <span class="title function_">normalizeNamespace</span>(<span class="function">(<span class="params">namespace, getters</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历规范化参数后的对象</span></span><br><span class="line">  <span class="comment">// getters 就是传递给 mapGetters 的 map 对象或者数组</span></span><br><span class="line">  <span class="title function_">normalizeMap</span>(getters).<span class="title function_">forEach</span>(<span class="function">(<span class="params">&#123; key, val &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    val = namespace + val</span><br><span class="line">    res[key] = <span class="keyword">function</span> <span class="title function_">mappedGetter</span> () &#123;</span><br><span class="line">      <span class="comment">// 一般不会传入 namespace 参数</span></span><br><span class="line">      <span class="keyword">if</span> (namespace &amp;&amp; !<span class="title function_">getModuleByNamespace</span>(<span class="variable language_">this</span>.<span class="property">$store</span>, <span class="string">&#x27;mapGetters&#x27;</span>, namespace)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果 getter 不存在则报错</span></span><br><span class="line">      <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !(val <span class="keyword">in</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">`[vuex] unknown getter: <span class="subst">$&#123;val&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 返回 getter 值, store.getters 可见上文 resetStoreVM 的分析</span></span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[val]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mark vuex getter for devtools</span></span><br><span class="line">    res[key].<span class="property">vuex</span> = <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>mapState在调用了 normalizeMap 函数后，把传入的 states 转换成由 {key, val} 对象构成的数组，接着调用 forEach 方法遍历这个数组，构造一个新的对象，这个新对象每个元素都返回一个新的函数 mappedState，函数对 val 的类型判断，如果 val 是一个函数，则直接调用这个 val 函数，把当前 store 上的 state 和 getters 作为参数，返回值作为 mappedState 的返回值；否则直接把 this.$store.state[val]作为 mappedState 的返回值。为了更直观的理解，我们看下最终mapState的效果</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: <span class="title function_">mapState</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">name</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-7-mutation和action有什么区别？"><a href="#1-7-mutation和action有什么区别？" class="headerlink" title="1.7 mutation和action有什么区别？"></a>1.7 mutation和action有什么区别？</h4><p><strong>参考答案：</strong></p>
<p><strong>mutation</strong>：更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于件： 每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进 行状态更改的地方，并且它会接受 state 作为第一个参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Action:</strong> Action 类似于 mutation，不同在于：</p>
<ol>
<li><p>Action 提交的是 mutation，而不是直接变更状态。</p>
</li>
<li><p>Action 可以包含任意异步操作。</p>
<p>让我们来注册一个简单的 action：</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.<span class="property">count</span>++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.<span class="title function_">commit</span>(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>扩展：</strong>事实上在 vuex 里面 actions 只是一个架构性的概念，并不是必须的，说到底只是一个函数，你在里面想干嘛都可以，只要最后触发 mutation 就行。异步竞态怎么处理那是用户自己的事情。</p>
<p>vuex 真正限制你的只有 mutation 必须是同步的这一点（在 redux 里面就好像 reducer 必须同步返回下一个状态一样）。同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。</p>
<h4 id="1-8-修改ElementUI-样式的几种方式"><a href="#1-8-修改ElementUI-样式的几种方式" class="headerlink" title="1.8 修改ElementUI 样式的几种方式?"></a>1.8 修改ElementUI 样式的几种方式?</h4><p><strong>参考答案：</strong></p>
<p>修改ElementUI 样式的方式有四种：</p>
<ol>
<li><p>新建全局样式表</p>
<p>新建 global.css 文件，并在 main.js 中引入。 global.css 文件一般都放在 src-&gt;assets 静态资源文件夹下的 style 文件夹下，在 main.js 的引用写法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;./assets/style/global.css&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 global.css 文件中写的样式，无论在哪一个 vue 单页面都会覆盖 ElementUI 默认的样式。</p>
</li>
<li><p>在当前-vue-单页面中添加一个新的style标签</p>
<p>在当前的vue单页面的style标签后，添加一对新的style标签，新的style标签中不要添加scoped属性。在有写scoped的style标签中书写的样式不会覆盖 ElementUI 默认的样式。</p>
</li>
<li><p>使用&#x2F;deep&#x2F;深度修改标签样式</p>
<p>找到需要修改的 ElementUI 标签的类名，然后在类名前加上&#x2F;deep&#x2F;，可以强制修改默认样式。这种方式可以直接用到有scoped属性的 style 标签中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 修改级联选择框的默认宽度</span><br><span class="line">/deep/ <span class="selector-class">.el-cascader</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过内联样式 或者 绑定类样式覆盖默认样式</p>
<p>通过内联样式 style ，绑定类样式的方式，可以在<strong>某些标签</strong>中可以直接覆盖默认样式，不是很通用。具体实例如下：</p>
</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:style</span>=<span class="string">&quot;selfstyle&quot;</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">selfstyle</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">color</span>: <span class="string">&quot;white&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">marginTop</span>: <span class="string">&quot;10px&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">width</span>: <span class="string">&quot;100px&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">backgroundColor</span>: <span class="string">&quot;cadetblue&quot;</span></span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过绑定修改样式方式修改：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-button</span> <span class="attr">:class</span>=<span class="string">&quot;[selfbutton]&quot;</span>&gt;</span>默认按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">selfbutton</span>: <span class="string">&quot;self-button&quot;</span></span></span><br><span class="line"><span class="language-javascript">      &#125;;</span></span><br><span class="line"><span class="language-javascript">    &#125; </span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;stylus&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet/stylus&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.self-button</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: white;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-Color</span>: cadetblue;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>扩展：</strong></p>
<p>第一种全局引入css文件的方式，适合于对elementUI整体的修改，比如整体配色的修改；<br>第二种添加一个style标签的形式，也能够实现修改默认样式的效果，但实际上因为是修改了全局的样式，因此 在不同的vue组件中修改同一个样式有可能会有冲突。<br>第三种方式通过 &#x2F;deep&#x2F; 的方式可以很方便的在vue组件中修改默认样式，也不会于其他页面有冲突。<br>第四种方式局限性比较大，可以使用，但不推荐使用。</p>
<h4 id="1-9-elementui-有什么用"><a href="#1-9-elementui-有什么用" class="headerlink" title="1.9 elementui 有什么用?"></a>1.9 elementui 有什么用?</h4><p><strong>参考答案：</strong></p>
<p><strong>Element-UI</strong>：是一套采用 Vue 2.0 作为基础框架实现的组件库，一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的组件库，提供了配套设计资源，帮助网站快速成型</p>
<p><strong>扩展：</strong></p>
<p>Element-UI特点：</p>
<p>一致性 Consistency</p>
<ul>
<li>与现实生活一致：与现实生活的流程、逻辑保持一致，遵循用户习惯的语言和概念；</li>
<li>在界面中一致：所有的元素和结构需保持一致，比如：设计样式、图标和文本、元素的位置等。</li>
</ul>
<p>反馈 Feedback</p>
<ul>
<li>控制反馈：通过界面样式和交互动效让用户可以清晰的感知自己的操作；</li>
<li>页面反馈：操作后，通过页面元素的变化清晰地展现当前状态。</li>
</ul>
<p>效率 Efficiency</p>
<ul>
<li>简化流程：设计简洁直观的操作流程；</li>
<li>清晰明确：语言表达清晰且表意明确，让用户快速理解进而作出决策；</li>
<li>帮助用户识别：界面简单直白，让用户快速识别而非回忆，减少用户记忆负担。</li>
</ul>
<p>可控 Controllability</p>
<ul>
<li>用户决策：根据场景可给予用户操作建议或安全提示，但不能代替用户进行决策；</li>
<li>结果可控：用户可以自由的进行操作，包括撤销、回退和终止当前操作等。</li>
</ul>
<h4 id="1-10-导航守卫"><a href="#1-10-导航守卫" class="headerlink" title="1.10 导航守卫"></a>1.10 导航守卫</h4><p><strong>参考答案：</strong></p>
<p>导航守卫主要用来<strong>通过跳转或取消的方式守卫导航</strong>。</p>
<p>简单的说，导航守卫就是路由跳转过程中的一些钩子函数。路由跳转是一个大的过程，这个大的过程分为跳转前中后等等细小的过程，在每一个过程中都有一函数，这个函数能让你操作一些其他的事儿的时机，这就是导航守卫。</p>
<p><strong>解析：</strong></p>
<p>路由守卫的具体方法：</p>
<ol>
<li><p>全局前置守卫</p>
<p>你可以使用 router.beforeEach 注册一个全局前置守卫：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; ... &#125;)</span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当一个导航开始时，全局前置守卫按照注册顺序调用。守卫是异步链式调用的，导航在最后的一层当中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;第一个全局前置守卫&#x27;</span>)</span><br><span class="line">&#125;.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;第二个全局前置守卫&#x27;</span></span><br><span class="line">&#125;.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;导航终于开始了&#x27;</span>) <span class="comment">// 导航在最后一层中</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>每个守卫方法接收三个参数（往后的守卫都大同小异）：</p>
<p>\1. to: Route: 即将要进入的目标 路由对象</p>
<p>\2. from: Route: 当前导航正要离开的路由</p>
<p>\3. next: Function: 一定要调用该方法将控制权交给下一个守卫，执行效果依赖 next 方法的参数。</p>
<p>next(): 进入下一个守卫。如果全部守卫执行完了。则导航的状态就是 confirmed (确认的)。</p>
<p>next(false): 中断当前的导航（把小明腿打断了）。如果浏览器的 URL 改变了 (可能是用户手动或者浏览器 后退按钮)，那么 URL 地址会重置到 from 路由对应的地址。</p>
<p>next(‘&#x2F;‘) 或者 next({ path: ‘&#x2F;‘ }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航（小 明被打断腿并且送回家了）。你可以向 next 传递任意位置对象，且允许设置诸如 replace: true、name: ‘home’ 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项。</p>
<p>next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递router.</p>
<p>onError() 注册过的回调。</p>
<p>注意：永远不要使用两次next，这会产生一些误会。</p>
<ol>
<li><p>全局解析守卫</p>
<p>这和 router.beforeEach 类似，但他总是被放在最后一个执行。</p>
</li>
<li><p>全局后置钩子</p>
<p>导航已经确认了的，小明已经到了外婆家了，你打断他的腿他也是在外婆家了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 你并不能调用next</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>路由独享的守卫</p>
<p>在路由内写的守卫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Foo</span>,</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内的守卫</p>
<p>5.1 beforeRouteEnter</p>
<p>5.2 beforeRouteUpdate (2.2 新增)</p>
<p>5.3 beforeRouteLeave</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Foo</span> = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 组件还未渲染出来，不能获取组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`，一般用来数据获取。</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>扩展：</strong></p>
<p>导航全过程</p>
<ul>
<li>导航被触发。</li>
<li>在准备离开的组件里调用 beforeRouteLeave 守卫。</li>
<li>调用全局的 beforeEach 守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。（如果你的组件是重用的）</li>
<li>在路由配置里调用 beforeEnter。</li>
<li>解析即将抵达的组件。</li>
<li>在即将抵达的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数。</li>
</ul>
<h4 id="1-11-路由守卫进行判断登录"><a href="#1-11-路由守卫进行判断登录" class="headerlink" title="1.11 路由守卫进行判断登录"></a>1.11 路由守卫进行判断登录</h4><p><strong>参考答案：</strong></p>
<p>在vue项目中，切换路由时肯定会碰到需要登录的路由，其原理就是在切换路径之前进行判断，你不可能进入页面再去判断有无登录重新定向到login，那样的话会导致页面已经渲染以及它的各种请求已经发出。</p>
<ol>
<li><p>如需要登录的路由可在main.js中统一处理（全局前置守卫）</p>
<p>我们可以在入口文件man.js里面进行配置，使用router.beforeEach方法，不懂得可以打印to，from的参数就ok，requireAuth可以随意换名的，只要man.js里面跟配置路由的routes里面的字段保持一致：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">matched</span>.<span class="title function_">some</span>(<span class="function"><span class="params">record</span> =&gt;</span> record.<span class="property">meta</span>.<span class="property">requireAuth</span>))&#123;  <span class="comment">// 判断该路由是否需要登录权限</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="variable language_">sessionStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>) &amp;&amp; !<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;token&#x27;</span>))&#123;</span><br><span class="line">      <span class="title function_">next</span>(&#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        <span class="attr">query</span>: &#123;<span class="attr">redirect</span>: to.<span class="property">fullPath</span>&#125;  <span class="comment">// 将跳转的路由path作为参数，登录成功后跳转到该路由</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="title function_">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Router</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">            <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">            <span class="attr">meta</span>: &#123;</span><br><span class="line">              <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">              <span class="attr">requireAuth</span>: <span class="literal">true</span>,  <span class="comment">// 添加该字段，表示进入这个路由是需要登录的</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;login&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Login</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>:<span class="string">&#x27;/register&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>:<span class="string">&#x27;register&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>:<span class="title class_">Register</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局后置守卫</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>单独路由独享守卫（与全局一致，可单独对某个路由进行配置）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="title class_">Foo</span>,</span><br><span class="line">      <span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组件内部路由守卫（可写在与生命周期同级位置）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;,</span><br><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-12-vue-router-实现懒加载"><a href="#1-12-vue-router-实现懒加载" class="headerlink" title="1.12 vue-router 实现懒加载"></a>1.12 vue-router 实现懒加载</h4><p><strong>参考答案：</strong></p>
<p>懒加载：当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。</p>
<p>实现：结合 Vue 的<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6">异步组件</a>和 Webpack 的<a target="_blank" rel="noopener" href="https://doc.webpack-china.org/guides/code-splitting-async/#require-ensure-/">代码分割功能</a>，可以实现路由组件的懒加载</p>
<ol>
<li><p>首先，可以将异步组件定义为返回一个 Promise 的工厂函数 (该函数返回的 Promise 应该 resolve 组件本身)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(&#123; <span class="comment">/* 组件定义对象 */</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 Webpack 2 中，我们可以使用<a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-dynamic-import">动态 import</a>语法来定义代码分块点 (split point)：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>) <span class="comment">// 返回 Promise</span></span><br></pre></td></tr></table></figure>

<p>结合这两者，这就是如何定义一个能够被 Webpack 自动代码分割的异步组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params"></span>) =&gt; <span class="keyword">import</span>(<span class="string">&#x27;./Foo.vue&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>在路由配置中什么都不需要改变，只需要像往常一样使用Foo：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/foo&#x27;</span>, <span class="attr">component</span>: <span class="title class_">Foo</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="1-13-js是如何监听HistoryRouter的变化的"><a href="#1-13-js是如何监听HistoryRouter的变化的" class="headerlink" title="1.13 js是如何监听HistoryRouter的变化的"></a>1.13 js是如何监听HistoryRouter的变化的</h4><p><strong>参考答案：</strong></p>
<p>通过浏览器的地址栏来改变切换页面，前端实现主要有两种方式：</p>
<ol>
<li><p>通过hash改变，利用window.onhashchange 监听。</p>
</li>
<li><p><strong>HistoryRouter：</strong>通过history的改变，进行js操作加载页面，然而history并不像hash那样简单，因为history的改变，除了浏览器的几个前进后退（使用 history.back(), history.forward()和 history.go() 方法来完成在用户历史记录中向后和向前的跳转。）等操作会主动触发popstate 事件，pushState，replaceState 并不会触发popstate事件，要解决history监听的问题，方法是：</p>
<p>首先完成一个订阅-发布模式，然后重写history.pushState, history.replaceState,并添加消息通知，这样一来只要history的无法实现监听函数就被我们加上了事件通知，只不过这里用的不是浏览器原生事件，而是通过我们创建的event-bus 来实现通知，然后触发事件订阅函数的执行。</p>
</li>
</ol>
<p>具体操作如下：</p>
<ol>
<li>订阅-发布模式示例</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;                  <span class="comment">// 订阅池</span></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = <span class="keyword">new</span> <span class="title class_">Date</span>() <span class="comment">//这里简单的运用时间戳做订阅池的ID</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span> = []       <span class="comment">//该事件下被订阅对象的集合</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">defined</span>(<span class="params"></span>)&#123;              <span class="comment">// 添加订阅者</span></span><br><span class="line">        <span class="title class_">Dep</span>.<span class="property">watch</span>.<span class="title function_">add</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;              <span class="comment">//通知订阅者有变化</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">subs</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">e, i</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> e.<span class="property">update</span> === <span class="string">&#x27;function&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                   e.<span class="property">update</span>.<span class="title function_">apply</span>(e)  <span class="comment">//触发订阅者更新函数</span></span><br><span class="line">                &#125; <span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">warr</span>(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Dep</span>.<span class="property">watch</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watch</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, fn</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;       <span class="comment">//订阅消息的名称</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">id</span> = <span class="keyword">new</span> <span class="title class_">Date</span>();   <span class="comment">//这里简单的运用时间戳做订阅者的ID</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">callBack</span> = fn;     <span class="comment">//订阅消息发送改变时-&gt;订阅者执行的回调函数     </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">add</span>(<span class="params">dep</span>) &#123;                  <span class="comment">//将订阅者放入dep订阅池</span></span><br><span class="line">       dep.<span class="property">subs</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params"></span>) &#123;                  <span class="comment">//将订阅者更新方法</span></span><br><span class="line">        <span class="keyword">var</span> cb = <span class="variable language_">this</span>.<span class="property">callBack</span>; <span class="comment">//赋值为了不改变函数内调用的this</span></span><br><span class="line">        <span class="title function_">cb</span>(<span class="variable language_">this</span>.<span class="property">name</span>);         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>重写history方法，并添加window.addHistoryListener事件机制。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addHistoryMethod = (<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> historyDep = <span class="keyword">new</span> <span class="title class_">Dep</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name === <span class="string">&#x27;historychange&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">name, fn</span>)&#123;</span><br><span class="line">                    <span class="keyword">var</span> event = <span class="keyword">new</span> <span class="title class_">Watch</span>(name, fn)</span><br><span class="line">                    <span class="title class_">Dep</span>.<span class="property">watch</span> = event;</span><br><span class="line">                    historyDep.<span class="title function_">defined</span>();</span><br><span class="line">                    <span class="title class_">Dep</span>.<span class="property">watch</span> = <span class="literal">null</span>;       <span class="comment">//置空供下一个订阅者使用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(name === <span class="string">&#x27;pushState&#x27;</span> || name === <span class="string">&#x27;replaceState&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">var</span> method = history[name];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">                    method.<span class="title function_">apply</span>(history, <span class="variable language_">arguments</span>);</span><br><span class="line">                    historyDep.<span class="title function_">notify</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;())</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">addHistoryListener</span> = <span class="title function_">addHistoryMethod</span>(<span class="string">&#x27;historychange&#x27;</span>);</span><br><span class="line">history.<span class="property">pushState</span> =  <span class="title function_">addHistoryMethod</span>(<span class="string">&#x27;pushState&#x27;</span>);</span><br><span class="line">history.<span class="property">replaceState</span> =  <span class="title function_">addHistoryMethod</span>(<span class="string">&#x27;replaceState&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="1-14-HashRouter-和-HistoryRouter的区别和原理"><a href="#1-14-HashRouter-和-HistoryRouter的区别和原理" class="headerlink" title="1.14 HashRouter 和 HistoryRouter的区别和原理"></a>1.14 HashRouter 和 HistoryRouter的区别和原理</h4><p><strong>参考答案：</strong></p>
<p><strong>vue-router</strong>是Vue官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。vue-router默认 hash 模式，还有一种是history模式。</p>
<p>原理：</p>
<ol>
<li><p>hash路由：hash模式的工作原理是hashchange事件，可以在window监听hash的变化。我们在url后面随便添加一个#xx触发这个事件。vue-router默认的是hash模式—使用URL的hash来模拟一个完整的URL,于是当URL改变的时候,页面不会重新加载,也就是单页应用了,当#后面的hash发生变化,不会导致浏览器向服务器发出请求,浏览器不发出请求就不会刷新页面,并且会触发hasChange这个事件,通过监听hash值的变化来实现更新页面部分内容的操作</p>
<p>对于hash模式会创建hashHistory对象,在访问不同的路由的时候,会发生两件事:<br>HashHistory.push()将新的路由添加到浏览器访问的历史的栈顶,和HasHistory.replace()替换到当前栈顶的路由</p>
</li>
<li><p>history路由：</p>
<p>主要使用HTML5的pushState()和replaceState()这两个api结合window.popstate事件（监听浏览器前进后退）来实现的,pushState()可以改变url地址且不会发送请求,replaceState()可以读取历史记录栈,还可以对浏览器记录进行修改</p>
</li>
</ol>
<p>区别：</p>
<ol>
<li>hash模式较丑，history模式较优雅</li>
<li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL</li>
<li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中</li>
<li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串</li>
<li>pushState可额外设置title属性供后续使用</li>
<li>hash兼容IE8以上，history兼容IE10以上</li>
<li>history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面，会导致404错误</li>
</ol>
<p>使用方法:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// hash路由原理***************************</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 监听hashchange方法</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;hashchange&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">innerHTML</span> = location.<span class="property">hash</span>.<span class="title function_">slice</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// history路由原理************************</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 利用html5的history的pushState方法结合window.popstate事件（监听浏览器前进后退）</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">routerChange</span> (pathname)&#123;</span></span><br><span class="line"><span class="language-javascript">            history.<span class="title function_">pushState</span>(<span class="literal">null</span>,<span class="literal">null</span>,pathname)</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">innerHTML</span> = location.<span class="property">pathname</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;popstate&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            div.<span class="property">innerHTML</span> = location.<span class="property">pathname</span></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-15-Vue-router-原理-哪个模式不会请求服务器"><a href="#1-15-Vue-router-原理-哪个模式不会请求服务器" class="headerlink" title="1.15 Vue router 原理, 哪个模式不会请求服务器"></a>1.15 Vue router 原理, 哪个模式不会请求服务器</h4><p><strong>参考答案：</strong></p>
<p>Vue router 的两种方法，hash模式不会请求服务器</p>
<p><strong>解析：</strong></p>
<ol>
<li>url的hash，就是通常所说的锚点#，javascript通过hashChange事件来监听url的变化，IE7以下需要轮询。比如这个 URL：<a target="_blank" rel="noopener" href="http://www.abc.com/#/hello%EF%BC%8Chash">http://www.abc.com/#/hello，hash</a> 的值为#&#x2F;hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此<strong>改变 hash 不会重新加载页面</strong>。</li>
<li>HTML5的History模式，它使url看起来像普通网站那样，以“&#x2F;”分割，没有#，单页面并没有跳转。不过使用这种模式需要服务端支持，服务端在接收到所有请求后，都只想同一个html文件，不然会出现404。因此单页面应用只有一个html，整个网站的内容都在这一个html里，通过js来处理。</li>
</ol>
<h4 id="1-16-组件通信的方式"><a href="#1-16-组件通信的方式" class="headerlink" title="1.16 组件通信的方式"></a>1.16 组件通信的方式</h4><p><strong>参考答案：</strong></p>
<p>组件通信的方式的方式有以下8种方法：</p>
<ol>
<li><p>props和$emit</p>
<p>这是最最常用的父子组件通信方式，父组件向子组件传递数据是通过prop传递的，子组件传递数据给父组件是通过$emit触发事件来做到的</p>
</li>
<li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true" alt="img">listeners</p>
<p>第一种方式处理父子组件之间的数据传输有一个问题：如果多层嵌套，父组件A下面有子组件B，组件B下面有组件C,这时如果组件A想传递数据给组件C怎么办呢?</p>
<p>如果采用第一种方法，我们必须让组件A通过prop传递消息给组件B，组件B在通过prop传递消息给组件C;要是组件A和组件C之间有更多的组件，那采用这种方式就很复杂了。从Vue 2.4开始，提供了<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true" alt="img">listeners来解决这个问题，能够让组件A之间传递消息给组件C。</p>
</li>
<li><p>v-model</p>
<p>父组件通过v-model传递值给子组件时，会自动传递一个value的prop属性，在子组件中通过this.$emit(‘input’,val)自动修改v-model绑定的值</p>
</li>
<li><p>provide和inject</p>
<p>父组件中通过provider来提供变量，然后在子组件中通过inject来注入变量。不论子组件有多深，只要调用了inject那么就可以注入provider中的数据。而不是局限于只能从当前父组件的prop属性来获取数据，只要在父组件的生命周期内，子组件都可以调用。</p>
</li>
<li><p>中央事件总线</p>
<p>上面方式都是处理的父子组件之间的数据传递，那如果两个组件不是父子关系呢?也就是兄弟组件如何通信?</p>
<p>这种情况下可以使用中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=emit%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8Cbus.&preview=true" alt="img">on监听触发的事件。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128629803/500809B9BD071EA8067678D9EC046261" alt="img"></p>
</li>
<li><p>parent和children</p>
</li>
<li><p>boradcast和dispatch</p>
<p>vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和on和emit的封装，但在一些基础组件中却很实用</p>
</li>
<li><p>vuex处理组件之间的数据交互</p>
<p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候才有上面这一些方法可能不利于项目的维护，vuex的做法就是将这一些公共的数据抽离出来，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的</p>
</li>
</ol>
<h4 id="1-17-vue组件间传值，-attrs和listeners-了解过吗？"><a href="#1-17-vue组件间传值，-attrs和listeners-了解过吗？" class="headerlink" title="1.17 vue组件间传值， attrs和listeners 了解过吗？"></a>1.17 vue组件间传值， attrs和listeners 了解过吗？</h4><p><strong>参考答案：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true" alt="img">listeners的作用：解决多层嵌套情况下，父组件A下面有子组件B，组件B下面有组件C，组件A传递数据给组件B的问题，这个方法是在Vue 2.4提出的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=attrs%E5%92%8C&preview=true" alt="img">listeners解决问题的过程：</p>
<p>C组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;C&#x27;</span>,&#123; </span><br><span class="line">     <span class="attr">template</span>:<span class="string">` </span></span><br><span class="line"><span class="string">     &lt;div&gt; </span></span><br><span class="line"><span class="string">     &lt;input type=&quot;text&quot; v-model=&quot;$attrs.messageC&quot; @input=&quot;passCData($attrs.messageC)&quot;&gt; </span></span><br><span class="line"><span class="string">     &lt;/div&gt; </span></span><br><span class="line"><span class="string">     `</span>, </span><br><span class="line">     <span class="attr">methods</span>:&#123; </span><br><span class="line">         <span class="title function_">passCData</span>(<span class="params">val</span>)&#123; </span><br><span class="line">             <span class="comment">//触发父组件A中的事件 </span></span><br><span class="line">             <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getCData&#x27;</span>,val) </span><br><span class="line">         &#125; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>B组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;B&#x27;</span>,&#123; </span><br><span class="line"> <span class="title function_">data</span>(<span class="params"></span>)&#123; </span><br><span class="line">     <span class="keyword">return</span> &#123; </span><br><span class="line">         <span class="attr">myMessage</span>:<span class="variable language_">this</span>.<span class="property">message</span> </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">template</span>:<span class="string">` </span></span><br><span class="line"><span class="string"> &lt;div&gt; </span></span><br><span class="line"><span class="string"> &lt;input type=&quot;text&quot; v-model=&quot;myMessage&quot; @input=&quot;passData(myMessage)&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;C v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/C&gt; </span></span><br><span class="line"><span class="string"> &lt;/div&gt; </span></span><br><span class="line"><span class="string"> `</span>, </span><br><span class="line"> <span class="comment">//得到父组件传递过来的数据 </span></span><br><span class="line"> <span class="attr">props</span>:[<span class="string">&#x27;message&#x27;</span>], </span><br><span class="line"> <span class="attr">methods</span>:&#123; </span><br><span class="line">     <span class="title function_">passData</span>(<span class="params">val</span>)&#123; </span><br><span class="line">         <span class="comment">//触发父组件中的事件 </span></span><br><span class="line">         <span class="variable language_">this</span>.$emit(<span class="string">&#x27;getChildData&#x27;</span>,val) </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p>A组件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;A&#x27;</span>,&#123; </span><br><span class="line"> <span class="attr">template</span>:<span class="string">` </span></span><br><span class="line"><span class="string"> &lt;div&gt; </span></span><br><span class="line"><span class="string"> &lt;p&gt;this is parent compoent!&lt;/p&gt; </span></span><br><span class="line"><span class="string"> &lt;B  </span></span><br><span class="line"><span class="string"> :messageC=&quot;messageC&quot;  </span></span><br><span class="line"><span class="string"> :message=&quot;message&quot;  </span></span><br><span class="line"><span class="string"> v-on:getCData=&quot;getCData&quot;  </span></span><br><span class="line"><span class="string"> v-on:getChildData=&quot;getChildData(message)&quot;&gt; </span></span><br><span class="line"><span class="string"> &lt;/B&gt; </span></span><br><span class="line"><span class="string"> &lt;/div&gt; </span></span><br><span class="line"><span class="string"> `</span>, </span><br><span class="line"> <span class="title function_">data</span>(<span class="params"></span>)&#123; </span><br><span class="line">     <span class="keyword">return</span> &#123; </span><br><span class="line">         <span class="attr">message</span>:<span class="string">&#x27;Hello&#x27;</span>, </span><br><span class="line">         <span class="attr">messageC</span>:<span class="string">&#x27;Hello c&#x27;</span> </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> <span class="attr">methods</span>:&#123; </span><br><span class="line">     <span class="title function_">getChildData</span>(<span class="params">val</span>)&#123; </span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;这是来自B组件的数据&#x27;</span>) </span><br><span class="line">     &#125;, </span><br><span class="line">     <span class="comment">//执行C子组件触发的事件 </span></span><br><span class="line">     <span class="title function_">getCData</span>(<span class="params">val</span>)&#123; </span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这是来自C组件的数据：&quot;</span>+val) </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;) </span><br><span class="line"><span class="keyword">var</span> app=<span class="keyword">new</span> <span class="title class_">Vue</span>(&#123; </span><br><span class="line"> <span class="attr">el</span>:<span class="string">&#x27;#app&#x27;</span>, </span><br><span class="line"> <span class="attr">template</span>:<span class="string">` </span></span><br><span class="line"><span class="string"> &lt;div&gt; </span></span><br><span class="line"><span class="string"> &lt;A&gt;&lt;/A&gt; </span></span><br><span class="line"><span class="string"> &lt;/div&gt; </span></span><br><span class="line"><span class="string"> `</span> </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ul>
<li>C组件中能直接触发getCData的原因在于 B组件调用C组件时 使用 v-on 绑定了$listeners 属性</li>
<li>通过v-bind 绑定$attrs属性，C组件可以直接获取到A组件中传递下来的props(除了B组件中props声明的)</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128655053/F98E288D764804F2354ED35EC26D637C" alt="img"></p>
<h4 id="1-18-组建传值，事件总线是怎么用的"><a href="#1-18-组建传值，事件总线是怎么用的" class="headerlink" title="1.18 组建传值，事件总线是怎么用的"></a>1.18 组建传值，事件总线是怎么用的</h4><p><strong>参考答案：</strong></p>
<p><strong>中央事件总线</strong>主要用来解决兄弟组件通信的问题。</p>
<p>实现方式：新建一个Vue事件bus对象，然后通过bus.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=emit%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%EF%BC%8Cbus.&preview=true" alt="img">on监听触发的事件。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(&#x27;brother1&#x27;,&#123; </span><br><span class="line"> data()&#123; </span><br><span class="line">     return &#123; </span><br><span class="line">        myMessage:&#x27;Hello brother1&#x27; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> template:` </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is brother1 compoent!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;myMessage&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;passData(myMessage)&quot;</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> `, </span><br><span class="line"> methods:&#123; </span><br><span class="line">     passData(val)&#123; </span><br><span class="line">         //触发全局事件globalEvent </span><br><span class="line">         bus.$emit(&#x27;globalEvent&#x27;,val) </span><br><span class="line">     &#125; </span><br><span class="line"> &#125; </span><br><span class="line">&#125;) </span><br><span class="line">Vue.component(&#x27;brother2&#x27;,&#123; </span><br><span class="line"> template:` </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>this is brother2 compoent!<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>brother1传递过来的数据：&#123;&#123;brothermessage&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> `, </span><br><span class="line"> data()&#123; </span><br><span class="line">     return &#123; </span><br><span class="line">         myMessage:&#x27;Hello brother2&#x27;, </span><br><span class="line">         brothermessage:&#x27;&#x27; </span><br><span class="line">     &#125; </span><br><span class="line"> &#125;, </span><br><span class="line"> mounted()&#123; </span><br><span class="line">      //绑定全局事件globalEvent </span><br><span class="line">     bus.$on(&#x27;globalEvent&#x27;,(val)=&gt;&#123; </span><br><span class="line">        this.brothermessage=val; </span><br><span class="line">     &#125;) </span><br><span class="line"> &#125; </span><br><span class="line">&#125;) </span><br><span class="line">//中央事件总线 </span><br><span class="line">var bus=new Vue(); </span><br><span class="line">var app=new Vue(&#123; </span><br><span class="line"> el:&#x27;#app&#x27;, </span><br><span class="line"> template:` </span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">brother1</span>&gt;</span><span class="tag">&lt;/<span class="name">brother1</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">brother2</span>&gt;</span><span class="tag">&lt;/<span class="name">brother2</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"> ` </span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128668820/B30491C32F761B02007519727B8B2DF9" alt="img"></p>
<h4 id="1-19-vue生命周期中异步加载在mouted还是create里实现"><a href="#1-19-vue生命周期中异步加载在mouted还是create里实现" class="headerlink" title="1.19 vue生命周期中异步加载在mouted还是create里实现"></a>1.19 vue生命周期中异步加载在mouted还是create里实现</h4><p><strong>参考答案:</strong></p>
<p>最常用的是在 created 钩子函数中调用异步请求</p>
<p><strong>解析：</strong></p>
<p>一般来说，可以在，created，mounted中都可以发送数据请求，但是，大部分时候，会在created发送请求。<br>Created的使用场景：如果页面首次渲染的就来自后端数据。因为，此时data已经挂载到vue实例了。<br>在 created（如果希望首次选的数据来自于后端，就在此处发请求）（只发了异步请求，渲染是在后端响应之后才进行的）、beforeMount、mounted（在mounted中发请求会进行二次渲染） 这三个钩子函数中进行调用。<br>因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。但是<strong>最常用的是在 created 钩子函数中调用异步请求</strong>，因为在 created 钩子函数中调用异步请求有两个优点：<br>第一点：能更快获取到服务端数据，减少页面 loading 时间；<br>第二点：放在 created 中有助于一致性，因为ssr 不支持 beforeMount 、mounted 钩子函数。</p>
<h4 id="1-20-vue钩子函数-重点问了keep-alive"><a href="#1-20-vue钩子函数-重点问了keep-alive" class="headerlink" title="1.20 vue钩子函数(重点问了keep-alive)"></a>1.20 vue钩子函数(重点问了keep-alive)</h4><p><strong>参考答案：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128702563/F5DFA24F5FDFC338D5D73739BF09C491" alt="img">Vue生命周期经历哪些阶段：</p>
<ol>
<li>总体来说：初始化、运行中、销毁</li>
<li>详细来说：开始创建、初始化数据、编译模板、挂载Dom、渲染→更新→渲染、销毁等一系列过程</li>
</ol>
<p>生命周期经历的阶段和钩子函数:</p>
<ol>
<li><p>实例化vue(组件)对象：new Vue()</p>
</li>
<li><p>初始化事件和生命周期 init events 和 init cycle</p>
</li>
<li><p>beforeCreate函数：</p>
<p>在实例初始化之后，数据观测 (data observer) 和 event&#x2F;watcher 事件配置之前被调用。</p>
<p>即此时vue（组件）对象被创建了，但是vue对象的属性还没有绑定，如data属性，computed属性还没有绑定，即没有值。</p>
<p>此时还没有数据和真实DOM。</p>
<p>即：属性还没有赋值，也没有动态创建template属性对应的HTML元素（二阶段的createUI函数还没有执行）</p>
</li>
<li><p>挂载数据（属性赋值）</p>
<p>包括 属性和computed的运算</p>
</li>
<li><p>Created函数：</p>
<p>vue对象的属性有值了，但是DOM还没有生成，$el属性还不存在。</p>
<p>此时有数据了，但是还没有真实的DOM</p>
<p>即：data，computed都执行了。属性已经赋值，但没有动态创建template属性对应的HTML元素，所以，此时如果更改数据不会触发updated函数</p>
<p>如果：数据的初始值就来自于后端，可以发送ajax，或者fetch请求获取数据，但是，此时不会触发updated函数</p>
<ol>
<li>检查</li>
</ol>
</li>
</ol>
<p>6.1 检查是否有el属性<br>检查vue配置，即new Vue{}里面的el项是否存在，有就继续检查template项。没有则等到手动绑定调用 vm.<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=mount()%E5%AE%8C%E6%88%90%E4%BA%86%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&preview=true" alt="img">el的绑定。</p>
<p>6.2 检查是否有template属性</p>
<p>检查配置中的template项，如果没有template进行填充被绑定区域，则被绑定区域的el对outerHTML（即 整个#app DOM对象，包括</p>
<p>和</p>
<p>标签）都作为被填充对象替换掉填充区域。即： 如果vue对象中有 template属性，那么，template后面的HTML会替换$el对应的内容。如果有render属 性，那么render就会替换template。 即：优先关系时： render &gt; template &gt; el</p>
<ol>
<li><p>beforeMount函数：</p>
<p>模板编译(template)、数据挂载(把数据显示在模板里)之前执行的钩子函数</p>
<p>此时 this.$el有值，但是数据还没有挂载到页面上。即此时页面中的<code>&#123;&#123;&#125;&#125;</code>里的变量还没有被数据替换</p>
</li>
<li><p>模板编译：用vue对象的数据（属性）替换模板中的内容</p>
</li>
<li><p>Mounted函数：</p>
<p>模板编译完成，数据挂载完毕</p>
<p>即：此时已经把数据挂载到了页面上，所以，页面上能够看到正确的数据了。</p>
<p>一般来说，我们在此处发送异步请求（ajax，fetch，axios等），获取服务器上的数据，显示在DOM里。</p>
</li>
<li><p>beforeUpdate函数：</p>
<p>组件更新之前执行的函数，只有数据更新后，才能调用（触发）beforeUpdate，注意：此数据一定是在模板上出现的数据，否则，不会，也没有必要触发组件更新（因为数据不出现在模板里，就没有必要再次渲染）</p>
<p>数据更新了，但是，vue（组件）对象对应的dom中的内部（innerHTML）没有变，所以叫作组件更新前</p>
</li>
<li><p>updated函数：</p>
<p>组件更新之后执行的函数</p>
<p>vue（组件）对象对应的dom中的内部（innerHTML）改变了，所以，叫作组件更新之后</p>
</li>
<li><p>activated函数：keep-alive组件激活时调用</p>
</li>
<li><p>activated函数：keep-alive组件停用时调用</p>
</li>
<li><p>beforeDestroy：vue（组件）对象销毁之前</p>
</li>
<li><p>destroyed：vue组件销毁后</p>
</li>
</ol>
<p>keep-alive</p>
<p><keep-alive></keep-alive>包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染。</p>
<p><strong>解析：</strong> 比如有一个列表和一个详情，那么用户就会经常执行打开详情&#x3D;&gt;返回列表&#x3D;&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<keep-alive></keep-alive>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p>
<h4 id="1-21-vue-keep-alive"><a href="#1-21-vue-keep-alive" class="headerlink" title="1.21 vue keep-alive"></a>1.21 vue keep-alive</h4><p><strong>参考答案：</strong></p>
<p><strong>keep-alive</strong>：keep-alive可以实现组件缓存，是Vue.js的一个内置组件。</p>
<p>作用：</p>
<ol>
<li>它能够把不活动的组件实例保存在内存中，而不是直接将其销毁</li>
<li>它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中</li>
</ol>
<p>使用方式：</p>
<ol>
<li>常用的两个属性include&#x2F;exclude，允许组件有条件的进行缓存。</li>
<li>两个生命周期activated&#x2F;deactivated，用来得知当前组件是否处于活跃状态。</li>
<li>keep-alive的中还运用了LRU(Least Recently Used)算法。</li>
</ol>
<p>原理：Vue 的缓存机制并不是直接存储 DOM 结构，而是将 DOM 节点抽象成了一个个 VNode节点，所以，keep- alive的缓存也是基于VNode节点的而不是直接存储DOM结构。</p>
<p>其实就是将需要缓存的VNode节点保存在this.cache中／在render时,如果VNode的name符合在缓存条件（可以用include以及exclude控制），则会从this.cache中取出之前缓存的VNode实例进行渲染。</p>
<h4 id="1-22-既然函数是引用类型，为什么-vue-的-data-还是可以用函数"><a href="#1-22-既然函数是引用类型，为什么-vue-的-data-还是可以用函数" class="headerlink" title="1.22 既然函数是引用类型，为什么 vue 的 data 还是可以用函数"></a>1.22 既然函数是引用类型，为什么 vue 的 data 还是可以用函数</h4><p><strong>参考答案：</strong></p>
<p>JavaScript只有函数构成作用域(注意理解作用域，<strong>只有函数{}构成作用域</strong>,对象的{}以及if(){}都不构成作用域),data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立，不会相互影响。</p>
<h4 id="1-23-vue-中-nextTick-作用与原理"><a href="#1-23-vue-中-nextTick-作用与原理" class="headerlink" title="1.23 vue 中 $nextTick 作用与原理"></a>1.23 vue 中 $nextTick 作用与原理</h4><p><strong>参考答案:</strong></p>
<p>作用：是为了可以获取更新后的DOM 。</p>
<p>由于Vue DOM更新是异步执行的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。为了确保得到更新后的DOM，所以设置了 Vue.nextTick()，就是在下次DOM更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的DOM。</p>
<p>原理：</p>
<p>在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用</p>
<ul>
<li>Promise</li>
<li>MutationObserver</li>
<li>setImmediate</li>
<li>如果以上都不行则采用setTimeout</li>
</ul>
<p>定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。</p>
<h4 id="1-24-vue的特性"><a href="#1-24-vue的特性" class="headerlink" title="1.24 vue的特性"></a>1.24 vue的特性</h4><p><strong>参考答案：</strong></p>
<ul>
<li>表单操作</li>
<li>自定义指令</li>
<li>计算属性</li>
<li>过滤器</li>
<li>侦听器</li>
<li>生命周期</li>
</ul>
<h4 id="1-25-v-if-v-show区别"><a href="#1-25-v-if-v-show区别" class="headerlink" title="1.25 v-if v-show区别"></a>1.25 v-if v-show区别</h4><p><strong>参考答案：</strong></p>
<p>v-show和v-if都是用来显示隐藏元素，v-if还有一个v-else配合使用，两者达到的效果都一样，但是v-if更消耗性能的，因为v-if在显示隐藏过程中有DOM的添加和删除，v-show就简单多了，只是操作css。</p>
<p><strong>解析：</strong></p>
<p>v-show</p>
<p>v-show不管条件是真还是假，第一次渲染的时候都会编译出来，也就是标签都会添加到DOM中。之后切换的时候，通过display: none;样式来显示隐藏元素。可以说只是改变css的样式，几乎不会影响什么性能。</p>
<p>v-if</p>
<p>在首次渲染的时候，如果条件为假，什么也不操作，页面当作没有这些元素。当条件为真的时候，开始局部编译，动态的向DOM元素里面添加元素。当条件从真变为假的时候，开始局部编译，卸载这些元素，也就是删除。</p>
<h4 id="1-26-Vue-列表为什么加-key"><a href="#1-26-Vue-列表为什么加-key" class="headerlink" title="1.26 Vue 列表为什么加 key"></a>1.26 Vue 列表为什么加 key</h4><p><strong>参考答案：</strong></p>
<p>vue中列表循环需加:key&#x3D;”唯一标识” 唯一标识且最好是静态的，因为vue组件高度复用增加Key可以标识组件的唯一性，为了更好地区别各个组件 key的作用主要是为了高效的更新虚拟DOM</p>
<p><strong>解析：</strong></p>
<p>vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设<br>首先讲一下diff算法的处理方法，对操作前后的dom树同一层的节点进行对比，一层一层对比，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128744220/448BD33DD57542E1E6A5B03957CC7034" alt="img"></p>
<p>当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。</p>
<p>比如一下这个情况：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128758816/EAA1B46F9F910D663C45A96D03B305C4" alt="img"></p>
<p>可以在B和C之间加一个F，Diff算法默认执行起来是这样的：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128776932/CE0C377B5746FC3BE8D5C8466A40AA87" alt="img"></p>
<p>即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？</p>
<p>所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。</p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://uploadfiles.nowcoder.com/images/20220301/4107856_1646128789653/536CB47A8208A5561AEC33A70324C88B" alt="img"></h4><h4 id="1-27-jquery-和-vue相比"><a href="#1-27-jquery-和-vue相比" class="headerlink" title="1.27 jquery 和 vue相比"></a>1.27 jquery 和 vue相比</h4><p><strong>参考答案：</strong></p>
<ol>
<li>jquery：轻量级的js库</li>
<li>vue：前端js库，是一个精简的MVVM，它专注于MVVM模型的viewModel层，通过双向数据绑定把view和model层连接起来，通过对数据的操作就可以完成对页面视图的渲染。</li>
</ol>
<table>
<thead>
<tr>
<th><strong>Vue</strong></th>
<th><strong>jQuery</strong></th>
</tr>
</thead>
<tbody><tr>
<td>数据驱动视图(MVVM思想:数据视图完全分离；数据驱动、双向绑定；)</td>
<td>直接操作DOM(获取、修改、赋值、事件绑定)</td>
</tr>
<tr>
<td>操作简单</td>
<td>操作麻烦</td>
</tr>
<tr>
<td>模块化</td>
<td>x</td>
</tr>
<tr>
<td>实现单页面</td>
<td>x</td>
</tr>
<tr>
<td>组件复用</td>
<td>x</td>
</tr>
<tr>
<td>性能高：使用的虚拟DOM，减少 dom的操作</td>
<td>x</td>
</tr>
</tbody></table>
<p><strong>扩展：</strong></p>
<ol>
<li>vue适用的场景：复杂数据操作的后台页面，表单填写页面<ol>
<li>jquery适用的场景：比如说一些html5的动画页面，一些需要js来操作页面样式的页面</li>
<li>二者也是可以结合起来一起使用的，vue侧重数据绑定，jquery侧重样式操作，动画效果等，则会更加高效率的完成业务需求</li>
</ol>
</li>
</ol>
<h4 id="1-28-为什么选择用vue做页面展示"><a href="#1-28-为什么选择用vue做页面展示" class="headerlink" title="1.28 为什么选择用vue做页面展示"></a>1.28 为什么选择用vue做页面展示</h4><p><strong>参考答案：</strong></p>
<ul>
<li><p>MVVM 框架：</p>
<p>Vue 正是使用了这种 MVVM 的框架形式，并且通过声明式渲染和响应式数据绑定的方式来帮助我们完全避免了对 DOM 的操作。</p>
</li>
<li><p>单页面应用程序</p>
<p>Vue 配合生态圈中的 Vue-Router 就可以非常方便的开发复杂的单页应用</p>
</li>
<li><p>轻量化与易学习</p>
<p>Vue 的生产版本只有 30.90KB 的大小，几乎不会对我们的网页加载速度产生影响。同时因为 Vue 只专注于视图层，单独的 Vue 就像一个库一样，所以使我们的学习成本变得非常低</p>
</li>
<li><p>渐进式与兼容性</p>
<p>Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。Vue 只做界面，而把其他的一切都交给了它的周边生态（axios（Vue 官方推荐）、Loadsh.js、Velocity.js 等）来做处理，这就要求 Vue 必须要对其他的框架拥有最大程度的兼容性</p>
</li>
<li><p>视图组件化</p>
<p>Vue 允许通过组件来去拼装一个页面，每个组件都是一个可复用的 Vue 实例，组件里面可以包含自己的数据，视图和代码逻辑。方便复用</p>
</li>
<li><p>虚拟 DOM（Virtual DOM）</p>
<p>Vue 之所以可以完全避免对 DOM 的操作，就是因为 Vue 采用了虚拟 DOM 的方式，不但避免了我们对 DOM 的复杂操作，并且大大的加快了我们应用的运行速度。</p>
</li>
<li><p>社区支持</p>
<p>得益于 Vue 的本土化身份（Vue 的作者为国人尤雨溪），再加上 Vue 本身的强大，所以涌现出了特别多的国内社区，这种情况在其他的框架身上是没有出现过的，这使得我们在学习或者使用 Vue 的时候，可以获得更多的帮助</p>
</li>
<li><p>未来的 Vue 走向</p>
<p>Vue 是由国人尤雨溪在 Google 工作的时候，为了方便自己的工作而开发出来的一个库，而在 Vue 被使用的过程中，突然发现越来越多的人喜欢上了它。所以尤雨溪就进入了一个边工作、边维护的状态，在这种情况下 Vue 依然迅速的发展。</p>
<p>而现在尤雨溪已经正式辞去了 Google 的工作，开始专职维护 Vue，同时加入进来的还有几十位优秀的开发者，他们致力于把 Vue 打造为最受欢迎的前端框架。事实证明 Vue 确实在往越来越好的方向发展了（从 Angular、React、Vue 的对比图中可以看出 Vue 的势头）。所以我觉得完全不需要担心未来 Vue 的发展，至少在没有新的颠覆性创新出来之前，Vue 都会越做越好。</p>
</li>
</ul>
<h4 id="1-29-vue-angular区别"><a href="#1-29-vue-angular区别" class="headerlink" title="1.29 vue&#x2F;angular区别"></a>1.29 vue&#x2F;angular区别</h4><p><strong>参考答案：</strong></p>
<ol>
<li><p>体积和性能</p>
<p>相较于vue，angular显得比较臃肿，比如一个包含了 Vuex + Vue Router 的 Vue 项目 (gzip 之后 30kB) ，而 angular-cli 生成的默认项目尺寸 (~65KB) 还是要小得多。</p>
<p>在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢。Vue.js使用基于依赖追踪的观察并且使用异步队列更新。所有的数据都是独立触发的。 对于庞大的应用来说，这个优化差异还是比较明显的</p>
</li>
<li><p>Virtual DOM vs Incremental DOM</p>
<p>在底层渲染方面，vue 使用的虚拟dom，而angular 使用的是Incremental DOM，Incremental DOM的优势在于低内开销</p>
</li>
<li><p>Vue 相比于 Angular 更加灵活，可以按照不同的需要去组织项目的应用代码。比如，甚至可以直接像引用jquery那样在HTML中引用vue，然后仅仅当成一个前端的模板引擎来用。</p>
</li>
<li><p>es6支持</p>
<p>es6是新一代的javascript标准，对JavaScript进行了大量的改进，使用es6开发已是基本需求。虽然有部分十分老旧的浏览器不支持es6，但是可以利用现代开发工具将es6编译成es5。在对es6的支持上两者都做得很好，（TS本身就是es6的超集）</p>
</li>
<li><p>学习曲线</p>
<p>针对前端而言，angular的学习曲线相对较大，vue学习起来更容易一些。不过对java和c的使用者而言，angular的静态检查、依赖注入的特性，以及面向对象的编程风格，使得angular都要更亲切一些。</p>
</li>
<li><p>使用热度</p>
<p>在使用热度上，vue具有更大优势，主要原因是更受数量庞大的中国开发者欢迎。较低的上手难度，易懂的开发文档，以及国人主导开发的光环，都使得vue更为流行</p>
</li>
</ol>
<h4 id="1-30-双向数据绑定原理"><a href="#1-30-双向数据绑定原理" class="headerlink" title="1.30 双向数据绑定原理"></a>1.30 双向数据绑定原理</h4><p><strong>参考答案：</strong></p>
<p>目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。</p>
<p>实现数据绑定的做法有大致如下几种：</p>
<p><strong>发布者-订阅者模式:</strong> 一般通过sub, pub的方式实现数据和视图的绑定监听，更新数据方式通常做法是vm.set(‘property’, value)</p>
<p>这种方式现在毕竟太low了，我们更希望通过vm.property &#x3D; value这种方式更新数据，同时自动更新视图，于是有了下面两种方式</p>
<p><strong>脏值检查:</strong> angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过setInterval()定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</p>
<ul>
<li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li>
<li>XHR响应事件 ( $http )</li>
<li>浏览器Location变更事件 ( $location )</li>
<li>Timer事件( <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=timeout,&preview=true" alt="img">interval )</li>
<li>执行 digest()或apply()</li>
</ul>
<p><strong>数据劫持:</strong> vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<h4 id="1-31-既然-Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢"><a href="#1-31-既然-Vue-通过数据劫持可以精准探测数据在具体dom上的变化-为什么还需要虚拟-DOM-diff-呢" class="headerlink" title="1.31 既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?"></a>1.31 既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</h4><p><strong>参考答案</strong>：</p>
<p><strong>前置知识:</strong> 依赖收集、虚拟 DOM、响应式系统</p>
<p>现代前端框架有两种方式侦测变化，一种是 <strong>pull</strong> ，一种是 <strong>push</strong></p>
<p><strong>pull:</strong> 其代表为React，我们可以回忆一下React是如何侦测到变化的,我们通常会用setStateAPI显式更新，然后React会进行一层层的Virtual Dom Diff操作找出差异，然后Patch到DOM上，React从一开始就不知道到底是哪发生了变化，只是知道「有变化了」，然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p>
<p><strong>push:</strong> Vue的响应式系统则是push的代表，当Vue程序初始化的时候就会对数据data进行依赖的收集，一但数据发生变化,响应式系统就会立刻得知。因此Vue是一开始就知道是「在哪发生变化了」，但是这又会产生一个问题，如果你熟悉Vue的响应式系统就知道，通常一个绑定一个数据就需要一个Watcher</p>
<p>一但我们的绑定细粒度过高就会产生大量的Watcher，这会带来内存以及依赖追踪的开销，而细粒度过低会无法精准侦测变化,因此Vue的设计是选择中等细粒度的方案,在组件级别进行push侦测的方式,也就是那套响应式系统,通常我们会第一时间侦测到发生变化的组件,然后在组件内部进行Virtual Dom Diff获取更加具体的差异，而Virtual Dom Diff则是pull操作，Vue是push+pull结合的方式进行变化侦测的。</p>
<h4 id="1-32-简单聊聊-new-Vue-以后发生的事情"><a href="#1-32-简单聊聊-new-Vue-以后发生的事情" class="headerlink" title="1.32 简单聊聊 new Vue 以后发生的事情"></a>1.32 简单聊聊 new Vue 以后发生的事情</h4><p><strong>参考答案</strong>：</p>
<ol>
<li>new Vue会调用 Vue 原型链上的_init方法对 Vue 实例进行初始化；</li>
<li>首先是initLifecycle初始化生命周期，对 Vue 实例内部的一些属性（如 children、parent、isMounted）进行初始化；</li>
<li>initEvents，初始化当前实例上的一些自定义事件（Vue.$on）；</li>
<li>initRender，解析slots绑定在 Vue 实例上，绑定createElement方法在实例上；</li>
<li>完成对生命周期、自定义事件等一系列属性的初始化后，触发生命周期钩子beforeCreate；</li>
<li>initInjections，在初始化data和props之前完成依赖注入（类似于 React.Context）；</li>
<li>initState，完成对data和props的初始化，同时对属性完成数据劫持内部，启用监听者对数据进行监听（更改）；</li>
<li>initProvide，对依赖注入进行解析；</li>
<li>完成对数据（state 状态）的初始化后，触发生命周期钩子created；</li>
<li>进入挂载阶段，将 vue 模板语法通过vue-loader解析成虚拟 DOM 树，虚拟 DOM 树与数据完成双向绑定，触发生命周期钩子beforeMount；</li>
<li>将解析好的虚拟 DOM 树通过 vue 渲染成真实 DOM，触发生命周期钩子mounted；</li>
</ol>
<h4 id="1-33-v-for中的key的理解？"><a href="#1-33-v-for中的key的理解？" class="headerlink" title="1.33 v-for中的key的理解？"></a>1.33 v-for中的key的理解？</h4><p><strong>参考答案</strong>：</p>
<p>需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点。主要是为了高效的更新虚拟DOM。</p>
<h4 id="1-34-vue首屏白屏如何解决？"><a href="#1-34-vue首屏白屏如何解决？" class="headerlink" title="1.34 vue首屏白屏如何解决？"></a>1.34 vue首屏白屏如何解决？</h4><p><strong>参考答案</strong>：</p>
<ol>
<li>路由懒加载</li>
<li>vue-cli开启打包压缩 和后台配合 gzip访问</li>
<li>进行cdn加速</li>
<li>开启vue服务渲染模式</li>
<li>用webpack的externals属性把不需要打包的库文件分离出去，减少打包后文件的大小</li>
<li>在生产环境中删除掉不必要的console.log</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> webpack.<span class="property">optimize</span>.<span class="title class_">UglifyJsPlugin</span>(&#123; <span class="comment">//添加-删除console.log</span></span><br><span class="line">    <span class="attr">compress</span>: &#123;</span><br><span class="line">      <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">drop_console</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sourceMap</span>: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br></pre></td></tr></table></figure>

<ol>
<li>开启nginx的gzip ,在nginx.conf配置文件中配置</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;  <span class="comment">//在 http中配置如下代码，</span></span><br><span class="line">   gzip on;</span><br><span class="line">   gzip_disable <span class="string">&quot;msie6&quot;</span>; </span><br><span class="line">   gzip_vary on; </span><br><span class="line">   gzip_proxied any;</span><br><span class="line">   gzip_comp_level <span class="number">8</span>; #压缩级别</span><br><span class="line">   gzip_buffers <span class="number">16</span> 8k;</span><br><span class="line">   #gzip_http_version <span class="number">1.1</span>;</span><br><span class="line">   gzip_min_length <span class="number">100</span>; #不压缩临界值</span><br><span class="line">   gzip_types text/plain application/javascript application/x-javascript text/css</span><br><span class="line">    application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>添加loading效果，给用户一种进度感受</li>
</ol>
<h4 id="1-35-vue单页面和传统的多页面区别？"><a href="#1-35-vue单页面和传统的多页面区别？" class="headerlink" title="1.35 vue单页面和传统的多页面区别？"></a>1.35 vue单页面和传统的多页面区别？</h4><p><strong>参考答案</strong>:</p>
<p>单页面应用（SPA）</p>
<p>通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。所有的页面内容都包含在这个所谓的主页面中。但在写的时候，还是会分开写（页面片段），然后在交互的时候由路由程序动态载入，单页面的页面跳转，仅刷新局部资源。多应用于pc端。</p>
<p>多页面（MPA）</p>
<p>指一个应用中有多个页面，页面跳转时是整页刷新</p>
<p><strong>单页面的优点：</strong></p>
<p>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点spa对服务器压力较小；前后端分离；页面效果会比较炫酷（比如切换页面内容时的专场动画）。</p>
<p><strong>单页面缺点：</strong></p>
<p>不利于seo；导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）；初次加载时耗时多；页面复杂度提高很多。</p>
<h4 id="1-36-refs、-parent的使用？"><a href="#1-36-refs、-parent的使用？" class="headerlink" title="1.36 refs、$parent的使用？"></a>1.36 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=root%E3%80%81&preview=true" alt="img">refs、$parent的使用？</h4><p><strong>参考答案</strong>：</p>
<p>$root</p>
<p>可以用来获取vue的根实例，比如在简单的项目中将公共数据放再vue根实例上(可以理解为一个全局 store ),因此可以代替vuex实现状态管理；</p>
<p>$refs</p>
<p>在子组件上使用ref特性后，this.属性可以直接访问该子组件。可以代替事件emit 和<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=on%20%E7%9A%84%E4%BD%9C%E7%94%A8%E3%80%82%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E6%98%AF%E9%80%9A%E8%BF%87ref%E7%89%B9%E6%80%A7%E4%B8%BA%E8%BF%99%E4%B8%AA%E5%AD%90%E7%BB%84%E4%BB%B6%E8%B5%8B%E4%BA%88%E4%B8%80%E4%B8%AAID%E5%BC%95%E7%94%A8%EF%BC%8C%E5%86%8D%E9%80%9A%E8%BF%87this.&preview=true" alt="img">refs.testId获取指定元素。注意：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://www.nowcoder.com/equation?tex=refs%E5%8F%AA%E4%BC%9A%E5%9C%A8%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%AE%8C%E6%88%90%E4%B9%8B%E5%90%8E%E7%94%9F%E6%95%88%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%AE%83%E4%BB%AC%E4%B8%8D%E6%98%AF%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E3%80%82%E8%BF%99%E4%BB%85%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9C%E5%AD%90%E7%BB%84%E4%BB%B6%E7%9A%84%E2%80%9C%E9%80%83%E7%94%9F%E8%88%B1%E2%80%9D%E2%80%94%E2%80%94%E4%BD%A0%E5%BA%94%E8%AF%A5%E9%81%BF%E5%85%8D%E5%9C%A8%E6%A8%A1%E6%9D%BF%E6%88%96%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%AD%E8%AE%BF%E9%97%AE&preview=true" alt="img">refs。</p>
<p>$parent</p>
<p>$parent属性可以用来从一个子组件访问父组件的实例，可以替代将数据以 prop 的方式传入子组件的方式；当变更父级组件的数据的时候，容易造成调试和理解难度增加；</p>
<h4 id="1-36-路由跳转和location-href的区别？"><a href="#1-36-路由跳转和location-href的区别？" class="headerlink" title="1.36 路由跳转和location.href的区别？"></a>1.36 路由跳转和location.href的区别？</h4><p><strong>参考答案</strong>：</p>
<p>使用location.href&#x3D;’&#x2F;url’来跳转，简单方便，但是刷新了页面；<br>使用路由方式跳转，无刷新页面，静态跳转；</p>
<h4 id="1-37-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？"><a href="#1-37-scss是什么？在vue-cli中的安装使用步骤是？有哪几大特性？" class="headerlink" title="1.37 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？"></a>1.37 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</h4><p><strong>参考答案</strong>：</p>
<p>css的预编译。</p>
<p>使用步骤：</p>
<ol>
<li>先装css-loader、node-loader、sass-loader等加载器模块</li>
<li>在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss</li>
<li>在同一个文件，配置一个module属性</li>
<li>然后在组件的style标签加上lang属性 ，例如：lang&#x3D;”scss”</li>
</ol>
<p>特性:</p>
<p>可以用变量，例如（$变量名称&#x3D;值）；<br>可以用混合器，例如（）<br>可以嵌套</p>
<h4 id="1-38-delete与vue-delete区别"><a href="#1-38-delete与vue-delete区别" class="headerlink" title="1.38 delete与vue.delete区别?"></a>1.38 delete与vue.delete区别?</h4><p>delte会删除数组的值，但是它依然会在内存中占位置<br>而vue.delete会删除数组在内存中的占位</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">delete</span> arr1[<span class="number">1</span>]</span><br><span class="line"><span class="variable language_">this</span>.$delete(arr2,<span class="number">2</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1)    <span class="comment">//【1, empty, 3】</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2)    <span class="comment">//【1,2】</span></span><br></pre></td></tr></table></figure>

<h4 id="1-39-computed和watch的区别"><a href="#1-39-computed和watch的区别" class="headerlink" title="1.39 computed和watch的区别"></a>1.39 computed和watch的区别</h4><p><strong>参考答案</strong>：</p>
<p>computed</p>
<p>计算结果并返回，只有当被计算的属性发生改变时才会触发（即：计算属性的结果会被缓存，除非依赖的响应属性变化才会重新及孙）</p>
<p>watch</p>
<p>监听某一个值，当被监听的值发生变化时，执行相关操作。</p>
<p>与computed的区别是，watch更加适用于监听某一个值得变化，并做对应操作，比如请求后太接口等。而computed适用于计算已有的值并返回结果。 监听简单数据类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;      </span><br><span class="line">    <span class="keyword">return</span>&#123;        </span><br><span class="line">        <span class="string">&#x27;first&#x27;</span>:<span class="number">2</span>     </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;,   </span><br><span class="line"> <span class="attr">watch</span>:&#123;      </span><br><span class="line">     <span class="title function_">first</span>(<span class="params"></span>)&#123;        </span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">first</span>)    </span><br><span class="line">    &#125;   </span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="1-40-Vue-为什么要用-vm-set-解决对象新增属性不能响应的问题-？你能说说如下代码的实现原理么？"><a href="#1-40-Vue-为什么要用-vm-set-解决对象新增属性不能响应的问题-？你能说说如下代码的实现原理么？" class="headerlink" title="1.40 Vue 为什么要用 vm.$set() 解决对象新增属性不能响应的问题 ？你能说说如下代码的实现原理么？"></a>1.40 Vue 为什么要用 vm.$set() 解决对象新增属性不能响应的问题 ？你能说说如下代码的实现原理么？</h4><p><strong>参考答案</strong>：</p>
<p><strong>1）Vue为什么要用vm.$set() 解决对象新增属性不能响应的问题</strong></p>
<ol>
<li>Vue使用了Object.defineProperty实现双向数据绑定</li>
<li>在初始化实例时对属性执行 getter&#x2F;setter 转化</li>
<li>属性必须在data对象上存在才能让Vue将它转换为响应式的（这也就造成了Vue无法检测到对象属性的添加或删除）</li>
</ol>
<p>所以Vue提供了Vue.set (object, propertyName, value) &#x2F; vm.$set (object, propertyName, value)</p>
<p><strong>2）框架本身是如何实现的呢?</strong></p>
<blockquote>
<p>Vue 源码位置：vue&#x2F;src&#x2F;core&#x2F;instance&#x2F;index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">set</span> (<span class="attr">target</span>: <span class="title class_">Array</span>&lt;any&gt; | <span class="title class_">Object</span>, <span class="attr">key</span>: any, <span class="attr">val</span>: any): any &#123;</span><br><span class="line">  <span class="comment">// target 为数组  </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(target) &amp;&amp; <span class="title function_">isValidArrayIndex</span>(key)) &#123;</span><br><span class="line">    <span class="comment">// 修改数组的长度, 避免索引&gt;数组长度导致splcie()执行有误</span></span><br><span class="line">    target.<span class="property">length</span> = <span class="title class_">Math</span>.<span class="title function_">max</span>(target.<span class="property">length</span>, key)</span><br><span class="line">    <span class="comment">// 利用数组的splice变异方法触发响应式  </span></span><br><span class="line">    target.<span class="title function_">splice</span>(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// key 已经存在，直接修改属性值  </span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (<span class="attr">target</span>: any).<span class="property">__ob__</span></span><br><span class="line">  <span class="comment">// target 本身就不是响应式数据, 直接赋值</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对属性进行响应式处理</span></span><br><span class="line">  <span class="title function_">defineReactive</span>(ob.<span class="property">value</span>, key, val)</span><br><span class="line">  ob.<span class="property">dep</span>.<span class="title function_">notify</span>()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们阅读以上源码可知，vm.$set 的实现原理是：</p>
<ol>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，</li>
<li>最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理</li>
</ol>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/47170023?v=4" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/47170023?v=4" title="头像" alt="头像"></a><div class="post-copyright__author_name">你别睡这么晚</div><div class="post-copyright__author_desc">我有一只小兔兔🐇</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/')">Vue八股文</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/wechatQRCode.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/wechatQRCode.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/qqQRCode.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/dont-sleep-so-late/CDN/images/qqQRCode.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=Vue八股文&amp;url=https://dont-sleep-so-late.github.io/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/Vue%E5%85%AB%E8%82%A1%E6%96%87/&amp;pic=" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="rm.copyPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dont-sleep-so-late.github.io" target="_blank">你别睡这么晚！</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/Vue/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>Vue<span class="tagsPageCount">18</span></a><a class="post-meta__box__tags" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>八股文<span class="tagsPageCount">6</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://avatars.githubusercontent.com/u/47170023?v=4" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/03/06/HTML/html5/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">HTML</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/07/%E5%85%AB%E8%82%A1%E6%96%87/JavaScript%E5%85%AB%E8%82%A1%E6%96%87/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaScript八股文</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/09/08/var%20that%20=%20this%E7%9A%84%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/" title="var that &#x3D;this 的用法详解"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-08</div><div class="title">var that &#x3D;this 的用法详解</div></div></a></div><div><a href="/2023/10/22/%E5%AF%8C%E6%96%87%E6%9C%AC%E7%BB%84%E4%BB%B6/" title="富文本组件(mavon-editor)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-10-22</div><div class="title">富文本组件(mavon-editor)</div></div></a></div><div><a href="/2023/09/13/%E5%B8%B8%E7%94%A8%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/" title="微信小程序常用配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-13</div><div class="title">微信小程序常用配置</div></div></a></div><div><a href="/2023/09/11/Vue/Vue-%E6%90%9C%E7%B4%A2%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95%E7%AE%A1%E7%90%86/" title="Vue 实现历史搜索记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-11</div><div class="title">Vue 实现历史搜索记录</div></div></a></div><div><a href="/2023/09/06/Vue/vue_cli/" title="Vue 脚手架"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-09-06</div><div class="title">Vue 脚手架</div></div></a></div><div><a href="/2024/03/05/Vue/Vue3%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE/" title="Vue3项目配置"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-05</div><div class="title">Vue3项目配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://avatars.githubusercontent.com/u/47170023?v=4" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://emotion.acs.pw/emotion/tieba/彩虹.png" ait="status"/></div></div><div class="author-info__description">一个学习笔记网站</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">你别睡这么晚</h1><div class="author-info__desc">我有一只小兔兔🐇</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/dont-sleep-so-late" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/14680267" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.</span> <span class="toc-text">Vue 的设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-MVVM-%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%92%8C-MVC-%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">介绍一下 MVVM 模式，和 MVC 模式有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.1.</span> <span class="toc-text">Vue2 的生命周期有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive-%E4%B8%AD%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">2.2.</span> <span class="toc-text">keep-alive 中的生命周期有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.3.</span> <span class="toc-text">父子组件生命周期执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%82%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.挂载阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.更新阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.销毁阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">2.3.4.</span> <span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E6%97%B6%E5%8F%91%E9%80%81%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E5%B9%B6%E8%A7%A3%E9%87%8A%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.4.</span> <span class="toc-text">平时发送异步请求在哪个生命周期，并解释原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E3%80%90%E5%BB%B6%E4%BC%B8%E9%97%AE%E7%AD%94%E3%80%91created-%E5%92%8C-mouted-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">【延伸问答】created 和 mouted 区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Vue%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">3.</span> <span class="toc-text">1. Vue面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-v-model-%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.1 v-model 作用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-v-model-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">3.0.2.</span> <span class="toc-text">1.2 v-model 实现原理？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-Vue2-0-%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E7%BC%BA%E9%99%B7%EF%BC%9F"><span class="toc-number">3.0.3.</span> <span class="toc-text">1.3 Vue2.0 双向绑定的缺陷？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Vue3-0-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.4.</span> <span class="toc-text">1.4 Vue3.0 实现数据双向绑定的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-Vuex%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%AF%8F%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8"><span class="toc-number">3.0.5.</span> <span class="toc-text">1.5 Vuex是什么，每个属性是干嘛的，如何使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-Vuex%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.6.</span> <span class="toc-text">1.6 Vuex实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-7-mutation%E5%92%8Caction%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.0.7.</span> <span class="toc-text">1.7 mutation和action有什么区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-8-%E4%BF%AE%E6%94%B9ElementUI-%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.8.</span> <span class="toc-text">1.8 修改ElementUI 样式的几种方式?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-9-elementui-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">3.0.9.</span> <span class="toc-text">1.9 elementui 有什么用?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-10-%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">3.0.10.</span> <span class="toc-text">1.10 导航守卫</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-11-%E8%B7%AF%E7%94%B1%E5%AE%88%E5%8D%AB%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%E7%99%BB%E5%BD%95"><span class="toc-number">3.0.11.</span> <span class="toc-text">1.11 路由守卫进行判断登录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-12-vue-router-%E5%AE%9E%E7%8E%B0%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.0.12.</span> <span class="toc-text">1.12 vue-router 实现懒加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-13-js%E6%98%AF%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%ACHistoryRouter%E7%9A%84%E5%8F%98%E5%8C%96%E7%9A%84"><span class="toc-number">3.0.13.</span> <span class="toc-text">1.13 js是如何监听HistoryRouter的变化的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-14-HashRouter-%E5%92%8C-HistoryRouter%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.14.</span> <span class="toc-text">1.14 HashRouter 和 HistoryRouter的区别和原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-15-Vue-router-%E5%8E%9F%E7%90%86-%E5%93%AA%E4%B8%AA%E6%A8%A1%E5%BC%8F%E4%B8%8D%E4%BC%9A%E8%AF%B7%E6%B1%82%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.0.15.</span> <span class="toc-text">1.15 Vue router 原理, 哪个模式不会请求服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-16-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.0.16.</span> <span class="toc-text">1.16 组件通信的方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-17-vue%E7%BB%84%E4%BB%B6%E9%97%B4%E4%BC%A0%E5%80%BC%EF%BC%8C-attrs%E5%92%8Clisteners-%E4%BA%86%E8%A7%A3%E8%BF%87%E5%90%97%EF%BC%9F"><span class="toc-number">3.0.17.</span> <span class="toc-text">1.17 vue组件间传值， attrs和listeners 了解过吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-18-%E7%BB%84%E5%BB%BA%E4%BC%A0%E5%80%BC%EF%BC%8C%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF%E6%98%AF%E6%80%8E%E4%B9%88%E7%94%A8%E7%9A%84"><span class="toc-number">3.0.18.</span> <span class="toc-text">1.18 组建传值，事件总线是怎么用的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-19-vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E5%9C%A8mouted%E8%BF%98%E6%98%AFcreate%E9%87%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.19.</span> <span class="toc-text">1.19 vue生命周期中异步加载在mouted还是create里实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-20-vue%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-%E9%87%8D%E7%82%B9%E9%97%AE%E4%BA%86keep-alive"><span class="toc-number">3.0.20.</span> <span class="toc-text">1.20 vue钩子函数(重点问了keep-alive)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-21-vue-keep-alive"><span class="toc-number">3.0.21.</span> <span class="toc-text">1.21 vue keep-alive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-22-%E6%97%A2%E7%84%B6%E5%87%BD%E6%95%B0%E6%98%AF%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88-vue-%E7%9A%84-data-%E8%BF%98%E6%98%AF%E5%8F%AF%E4%BB%A5%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.22.</span> <span class="toc-text">1.22 既然函数是引用类型，为什么 vue 的 data 还是可以用函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-23-vue-%E4%B8%AD-nextTick-%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.23.</span> <span class="toc-text">1.23 vue 中 $nextTick 作用与原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-24-vue%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">3.0.24.</span> <span class="toc-text">1.24 vue的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-25-v-if-v-show%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.25.</span> <span class="toc-text">1.25 v-if v-show区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-26-Vue-%E5%88%97%E8%A1%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8A%A0-key"><span class="toc-number">3.0.26.</span> <span class="toc-text">1.26 Vue 列表为什么加 key</span></a></li><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-number">3.0.27.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-27-jquery-%E5%92%8C-vue%E7%9B%B8%E6%AF%94"><span class="toc-number">3.0.28.</span> <span class="toc-text">1.27 jquery 和 vue相比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-28-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E7%94%A8vue%E5%81%9A%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA"><span class="toc-number">3.0.29.</span> <span class="toc-text">1.28 为什么选择用vue做页面展示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-29-vue-angular%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.30.</span> <span class="toc-text">1.29 vue&#x2F;angular区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-30-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86"><span class="toc-number">3.0.31.</span> <span class="toc-text">1.30 双向数据绑定原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-31-%E6%97%A2%E7%84%B6-Vue-%E9%80%9A%E8%BF%87%E6%95%B0%E6%8D%AE%E5%8A%AB%E6%8C%81%E5%8F%AF%E4%BB%A5%E7%B2%BE%E5%87%86%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%85%B7%E4%BD%93dom%E4%B8%8A%E7%9A%84%E5%8F%98%E5%8C%96-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F-DOM-diff-%E5%91%A2"><span class="toc-number">3.0.32.</span> <span class="toc-text">1.31 既然 Vue 通过数据劫持可以精准探测数据在具体dom上的变化,为什么还需要虚拟 DOM diff 呢?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-32-%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A-new-Vue-%E4%BB%A5%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E4%BA%8B%E6%83%85"><span class="toc-number">3.0.33.</span> <span class="toc-text">1.32 简单聊聊 new Vue 以后发生的事情</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-33-v-for%E4%B8%AD%E7%9A%84key%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"><span class="toc-number">3.0.34.</span> <span class="toc-text">1.33 v-for中的key的理解？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-34-vue%E9%A6%96%E5%B1%8F%E7%99%BD%E5%B1%8F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">3.0.35.</span> <span class="toc-text">1.34 vue首屏白屏如何解决？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-35-vue%E5%8D%95%E9%A1%B5%E9%9D%A2%E5%92%8C%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.0.36.</span> <span class="toc-text">1.35 vue单页面和传统的多页面区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-36-refs%E3%80%81-parent%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">3.0.37.</span> <span class="toc-text">1.36 refs、$parent的使用？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-36-%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E5%92%8Clocation-href%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.0.38.</span> <span class="toc-text">1.36 路由跳转和location.href的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-37-scss%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%9C%A8vue-cli%E4%B8%AD%E7%9A%84%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4%E6%98%AF%EF%BC%9F%E6%9C%89%E5%93%AA%E5%87%A0%E5%A4%A7%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">3.0.39.</span> <span class="toc-text">1.37 scss是什么？在vue.cli中的安装使用步骤是？有哪几大特性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-38-delete%E4%B8%8Evue-delete%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.40.</span> <span class="toc-text">1.38 delete与vue.delete区别?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-39-computed%E5%92%8Cwatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.0.41.</span> <span class="toc-text">1.39 computed和watch的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-40-Vue-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-vm-set-%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E6%96%B0%E5%A2%9E%E5%B1%9E%E6%80%A7%E4%B8%8D%E8%83%BD%E5%93%8D%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98-%EF%BC%9F%E4%BD%A0%E8%83%BD%E8%AF%B4%E8%AF%B4%E5%A6%82%E4%B8%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%88%EF%BC%9F"><span class="toc-number">3.0.42.</span> <span class="toc-text">1.40 Vue 为什么要用 vm.$set() 解决对象新增属性不能响应的问题 ？你能说说如下代码的实现原理么？</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/02/js/%E8%AF%AD%E9%9F%B3%E6%96%87%E5%AD%97%E4%BA%92%E8%BD%AC/" title="前端AI语音方面的实现">前端AI语音方面的实现</a><time datetime="2024-04-02T14:31:15.000Z" title="发表于 2024-04-02 22:31:15">2024-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/02/%E5%85%AB%E8%82%A1%E6%96%87/%E5%BC%82%E6%AD%A5%E7%9B%B8%E5%85%B3/" title="异步相关">异步相关</a><time datetime="2024-04-02T03:31:36.000Z" title="发表于 2024-04-02 11:31:36">2024-04-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/01/%E5%85%AB%E8%82%A1%E6%96%87/HTMl%E5%85%AB%E8%82%A1%E6%96%87/" title="HTML八股文">HTML八股文</a><time datetime="2024-04-01T15:31:36.000Z" title="发表于 2024-04-01 23:31:36">2024-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/01/%E5%85%AB%E8%82%A1%E6%96%87/%E6%89%93%E5%8C%85/" title="webpack">webpack</a><time datetime="2024-04-01T15:31:36.000Z" title="发表于 2024-04-01 23:31:36">2024-04-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/01/%E5%85%AB%E8%82%A1%E6%96%87/ES5%E5%92%8CES6/" title="ES5和ES6">ES5和ES6</a><time datetime="2024-04-01T15:22:36.000Z" title="发表于 2024-04-01 23:22:36">2024-04-01</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2023 - 2024 By <a class="footer-bar-link" href="/" title="你别睡这么晚" target="_blank">你别睡这么晚</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-Theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">6</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" href="https://dont-sleep-so-late.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 文档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=150767257&amp;server=netease"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/API%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">API文档管理<sup>1</sup></a><a href="/tags/Array/" style="font-size: 0.88rem;">Array<sup>1</sup></a><a href="/tags/CSS/" style="font-size: 0.88rem;">CSS<sup>4</sup></a><a href="/tags/CSS-Less/" style="font-size: 0.88rem;">CSS Less<sup>1</sup></a><a href="/tags/CSS-flex/" style="font-size: 0.88rem;">CSS flex<sup>1</sup></a><a href="/tags/CSS-grid/" style="font-size: 0.88rem;">CSS grid<sup>1</sup></a><a href="/tags/ES6/" style="font-size: 0.88rem;">ES6<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>3</sup></a><a href="/tags/HTML/" style="font-size: 0.88rem;">HTML<sup>2</sup></a><a href="/tags/HTML5/" style="font-size: 0.88rem;">HTML5<sup>1</sup></a><a href="/tags/HTTP/" style="font-size: 0.88rem;">HTTP<sup>1</sup></a><a href="/tags/JS-array/" style="font-size: 0.88rem;">JS array<sup>1</sup></a><a href="/tags/JS-%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 0.88rem;">JS 模块化<sup>1</sup></a><a href="/tags/JavaSciprt/" style="font-size: 0.88rem;">JavaSciprt<sup>2</sup></a><a href="/tags/JavaScript/" style="font-size: 0.88rem;">JavaScript<sup>7</sup></a><a href="/tags/Mybatis/" style="font-size: 0.88rem;">Mybatis<sup>2</sup></a><a href="/tags/MybatisPlus/" style="font-size: 0.88rem;">MybatisPlus<sup>1</sup></a><a href="/tags/OpenAPI-Swagger/" style="font-size: 0.88rem;">OpenAPI/Swagger<sup>1</sup></a><a href="/tags/Router/" style="font-size: 0.88rem;">Router<sup>1</sup></a><a href="/tags/SpringBoot/" style="font-size: 0.88rem;">SpringBoot<sup>1</sup></a><a href="/tags/SpringMVC/" style="font-size: 0.88rem;">SpringMVC<sup>1</sup></a><a href="/tags/TCP/" style="font-size: 0.88rem;">TCP<sup>1</sup></a><a href="/tags/Vue/" style="font-size: 0.88rem;">Vue<sup>18</sup></a><a href="/tags/Vue3/" style="font-size: 0.88rem;">Vue3<sup>5</sup></a><a href="/tags/Vuex/" style="font-size: 0.88rem;">Vuex<sup>1</sup></a><a href="/tags/Vue%E6%8F%92%E4%BB%B6/" style="font-size: 0.88rem;">Vue插件<sup>1</sup></a><a href="/tags/Vue%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80/" style="font-size: 0.88rem;">Vue核心基础<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6/" style="font-size: 0.88rem;">Vue组件<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">Vue组件化编程<sup>1</sup></a><a href="/tags/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1/" style="font-size: 0.88rem;">Vue组件间通信<sup>1</sup></a><a href="/tags/Vue%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/" style="font-size: 0.88rem;">Vue网络请求<sup>1</sup></a><a href="/tags/Vue%E8%84%9A%E6%89%8B%E6%9E%B6/" style="font-size: 0.88rem;">Vue脚手架<sup>1</sup></a><a href="/tags/css/" style="font-size: 0.88rem;">css<sup>1</sup></a><a href="/tags/sass/" style="font-size: 0.88rem;">sass<sup>1</sup></a><a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 0.88rem;">前端开发<sup>1</sup></a><a href="/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" style="font-size: 0.88rem;">实用技巧<sup>1</sup></a><a href="/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" style="font-size: 0.88rem;">微信小程序<sup>5</sup></a><a href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 0.88rem;">正则表达式<sup>1</sup></a><a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9F%A5%E8%AF%86/" style="font-size: 0.88rem;">浏览器知识<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%AB%99%E6%8E%A8%E8%8D%90/" style="font-size: 0.88rem;">网站推荐<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="150767257" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://music.163.com/#/playlist?id=150767257&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.20/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.4/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("09/05/2023 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2023 By 安知鱼 V1.6.6",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 你别睡这么晚 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.56.5/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "visitor@anheyu.com";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>